import React from 'react';
import {\n  renderWithProviders,\n  createTestData,\n  createMockProps,\n  testUtils,\n  vi,\n  expect,\n  describe,\n  it,\n  beforeEach,\n  afterEach,\n  screen,\n  waitFor,\n  act\n} from '../../utils/comprehensive-test-providers';\nimport { UnifiedTacticsBoard } from '../../../components/tactics/UnifiedTacticsBoard';\nimport PlayerDisplaySettings from '../../../components/tactics/PlayerDisplaySettings';\nimport PositionalBench from '../../../components/tactics/PositionalBench';\nimport type { Player, Formation } from '../../../types';\n\n/**\n * Performance testing suite for tactical board components\n * Tests rendering performance, memory usage, and optimization effectiveness\n */\n\ndescribe('Tactical Board Performance - Comprehensive Test Suite', () => {\n  let performanceMonitor: {\n    startTime: number;\n    endTime: number;\n    memoryUsage: any;\n    renderCount: number;\n  };\n\n  beforeEach(() => {\n    performanceMonitor = {\n      startTime: 0,\n      endTime: 0,\n      memoryUsage: null,\n      renderCount: 0\n    };\n\n    // Mock performance APIs\n    global.performance = {\n      ...global.performance,\n      mark: vi.fn(),\n      measure: vi.fn(),\n      getEntriesByType: vi.fn(() => []),\n      getEntriesByName: vi.fn(() => []),\n      now: vi.fn(() => Date.now()),\n      memory: {\n        usedJSHeapSize: 10000000,\n        totalJSHeapSize: 20000000,\n        jsHeapSizeLimit: 100000000\n      }\n    } as any;\n  });\n\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('UnifiedTacticsBoard Performance', () => {\n    it('should render initial board within performance budget', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      const startTime = performance.now();\n      \n      const { container } = renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      await waitFor(() => {\n        expect(container.querySelector('[role=\"application\"]')).toBeInTheDocument();\n      });\n\n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n\n      // Should render within 1 second for initial load\n      expect(renderTime).toBeLessThan(1000);\n    });\n\n    it('should handle large datasets efficiently', async () => {\n      const largeDataset = createTestData.performance(500); // 500 players\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      const startTime = performance.now();\n      \n      const { container } = renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: {\n            players: largeDataset.players,\n            formations: { [largeDataset.formation.id]: largeDataset.formation },\n            activeFormationIds: { home: largeDataset.formation.id },\n            drawings: [],\n            playbook: {},\n            matchState: null,\n            notifications: []\n          }\n        }\n      );\n\n      await waitFor(() => {\n        expect(container.querySelector('[role=\"application\"]')).toBeInTheDocument();\n      }, { timeout: 5000 });\n\n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n\n      // Should handle large datasets within 3 seconds\n      expect(renderTime).toBeLessThan(3000);\n    });\n\n    it('should implement virtualization for large player counts', async () => {\n      const massiveDataset = createTestData.performance(1000); // 1000 players\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      const { container } = renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: {\n            players: massiveDataset.players,\n            formations: { [massiveDataset.formation.id]: massiveDataset.formation },\n            activeFormationIds: { home: massiveDataset.formation.id },\n            drawings: [],\n            playbook: {},\n            matchState: null,\n            notifications: []\n          }\n        }\n      );\n\n      await waitFor(() => {\n        expect(container.querySelector('[role=\"application\"]')).toBeInTheDocument();\n      });\n\n      // Should not render all 1000 players at once (virtualization)\n      const renderedPlayers = container.querySelectorAll('[data-testid*=\"player\"]');\n      expect(renderedPlayers.length).toBeLessThan(200); // Much less than total\n    });\n\n    it('should optimize re-renders with React.memo', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n      \n      let renderCount = 0;\n      const TestWrapper = () => {\n        renderCount++;\n        return (\n          <UnifiedTacticsBoard {...mockProps} />\n        );\n      };\n\n      const { rerender } = renderWithProviders(\n        <TestWrapper />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      const initialRenderCount = renderCount;\n\n      // Re-render with same props (should be memoized)\n      rerender(<TestWrapper />);\n\n      // Should not cause unnecessary re-renders\n      expect(renderCount - initialRenderCount).toBeLessThanOrEqual(2);\n    });\n\n    it('should use deferred values for performance optimization', async () => {\n      const testData = createTestData.performance(100);\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      const startTime = performance.now();\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: {\n            players: testData.players,\n            formations: { [testData.formation.id]: testData.formation },\n            activeFormationIds: { home: testData.formation.id },\n            drawings: [],\n            playbook: {},\n            matchState: null,\n            notifications: []\n          }\n        }\n      );\n\n      await waitFor(() => {\n        expect(screen.getByRole('application')).toBeInTheDocument();\n      });\n\n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n\n      // Deferred values should keep initial render fast\n      expect(renderTime).toBeLessThan(1500);\n    });\n  });\n\n  describe('PlayerDisplaySettings Performance', () => {\n    it('should update settings without causing layout thrashing', async () => {\n      const mockProps = createMockProps.playerDisplaySettings();\n      \n      const { rerender } = renderWithProviders(\n        <PlayerDisplaySettings {...mockProps} />\n      );\n\n      const startTime = performance.now();\n\n      // Rapidly change multiple settings\n      for (let i = 0; i < 10; i++) {\n        const newConfig = {\n          ...mockProps.config,\n          showNames: i % 2 === 0,\n          showNumbers: i % 3 === 0,\n          size: (i % 3 === 0 ? 'small' : i % 3 === 1 ? 'medium' : 'large') as const\n        };\n\n        rerender(\n          <PlayerDisplaySettings {...mockProps} config={newConfig} />\n        );\n      }\n\n      const endTime = performance.now();\n      const updateTime = endTime - startTime;\n\n      // Rapid updates should complete quickly\n      expect(updateTime).toBeLessThan(500);\n    });\n\n    it('should debounce rapid configuration changes', async () => {\n      const mockProps = createMockProps.playerDisplaySettings();\n      \n      renderWithProviders(\n        <PlayerDisplaySettings {...mockProps} />\n      );\n\n      const startTime = performance.now();\n\n      // Simulate rapid user interactions\n      const toggles = screen.getAllByRole('checkbox');\n      \n      for (const toggle of toggles.slice(0, 5)) {\n        await act(async () => {\n          toggle.click();\n          await new Promise(resolve => setTimeout(resolve, 50));\n        });\n      }\n\n      const endTime = performance.now();\n      const interactionTime = endTime - startTime;\n\n      // Should handle rapid interactions smoothly\n      expect(interactionTime).toBeLessThan(1000);\n    });\n  });\n\n  describe('PositionalBench Performance', () => {\n    it('should handle large player lists efficiently', async () => {\n      const largePlayerList = createTestData.performance(200).players;\n      const mockProps = createMockProps.positionalBench();\n\n      const startTime = performance.now();\n\n      renderWithProviders(\n        <PositionalBench {...mockProps} players={largePlayerList} />\n      );\n\n      await waitFor(() => {\n        expect(screen.getByTestId('positional-bench')).toBeInTheDocument();\n      });\n\n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n\n      // Should render large lists within reasonable time\n      expect(renderTime).toBeLessThan(2000);\n    });\n\n    it('should virtualize when dealing with massive player lists', async () => {\n      const massivePlayerList = createTestData.performance(1000).players;\n      const mockProps = createMockProps.positionalBench();\n\n      const { container } = renderWithProviders(\n        <PositionalBench \n          {...mockProps} \n          players={massivePlayerList}\n          virtualized={true}\n        />\n      );\n\n      await waitFor(() => {\n        expect(screen.getByTestId('positional-bench')).toBeInTheDocument();\n      });\n\n      // Should only render visible players\n      const renderedPlayerCards = container.querySelectorAll('[data-testid*=\"player-card\"]');\n      expect(renderedPlayerCards.length).toBeLessThan(100); // Much less than 1000\n    });\n\n    it('should optimize filtering and searching', async () => {\n      const playerList = createTestData.performance(500).players;\n      const mockProps = createMockProps.positionalBench();\n\n      renderWithProviders(\n        <PositionalBench \n          {...mockProps} \n          players={playerList}\n          searchable={true}\n        />\n      );\n\n      const startTime = performance.now();\n\n      // Perform search\n      const searchInput = screen.getByPlaceholderText(/search players/i);\n      \n      await act(async () => {\n        searchInput.focus();\n        // Simulate typing (which should be debounced)\n        for (const char of 'test') {\n          fireEvent.change(searchInput, { target: { value: char } });\n          await new Promise(resolve => setTimeout(resolve, 10));\n        }\n      });\n\n      await waitFor(() => {\n        expect(searchInput).toHaveValue('test');\n      });\n\n      const endTime = performance.now();\n      const searchTime = endTime - startTime;\n\n      // Search should be fast even with large datasets\n      expect(searchTime).toBeLessThan(1000);\n    });\n  });\n\n  describe('Memory Usage and Leaks', () => {\n    it('should not create memory leaks on component unmount', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      const { unmount } = renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      await waitFor(() => {\n        expect(screen.getByRole('application')).toBeInTheDocument();\n      });\n\n      // Get initial memory usage\n      const initialMemory = (performance as any).memory?.usedJSHeapSize || 0;\n\n      // Unmount component\n      unmount();\n\n      // Force garbage collection (if available)\n      if (global.gc) {\n        global.gc();\n      }\n\n      // Wait for cleanup\n      await new Promise(resolve => setTimeout(resolve, 100));\n\n      const finalMemory = (performance as any).memory?.usedJSHeapSize || 0;\n\n      // Memory usage should not increase significantly after unmount\n      const memoryIncrease = finalMemory - initialMemory;\n      expect(memoryIncrease).toBeLessThan(5000000); // 5MB threshold\n    });\n\n    it('should cleanup event listeners and subscriptions', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      // Mock addEventListener to track listener cleanup\n      const addEventListenerSpy = vi.spyOn(window, 'addEventListener');\n      const removeEventListenerSpy = vi.spyOn(window, 'removeEventListener');\n\n      const { unmount } = renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      await waitFor(() => {\n        expect(screen.getByRole('application')).toBeInTheDocument();\n      });\n\n      const addedListeners = addEventListenerSpy.mock.calls.length;\n      \n      // Unmount component\n      unmount();\n\n      const removedListeners = removeEventListenerSpy.mock.calls.length;\n\n      // Should remove as many listeners as were added\n      expect(removedListeners).toBeGreaterThanOrEqual(addedListeners * 0.8); // Allow some tolerance\n    });\n  });\n\n  describe('Animation and Interaction Performance', () => {\n    it('should maintain 60fps during animations', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // Mock requestAnimationFrame to measure frame timing\n      const frameTimes: number[] = [];\n      let frameCount = 0;\n      \n      const originalRAF = window.requestAnimationFrame;\n      window.requestAnimationFrame = vi.fn((callback) => {\n        frameCount++;\n        const now = performance.now();\n        frameTimes.push(now);\n        \n        return originalRAF(() => {\n          callback(now);\n        });\n      });\n\n      // Trigger animations by interacting with the board\n      const field = screen.getByRole('main');\n      \n      await act(async () => {\n        // Simulate rapid interactions that might trigger animations\n        for (let i = 0; i < 10; i++) {\n          fireEvent.click(field, { clientX: 100 + i * 20, clientY: 100 + i * 20 });\n          await new Promise(resolve => setTimeout(resolve, 16)); // ~60fps\n        }\n      });\n\n      // Calculate average frame time\n      if (frameTimes.length > 1) {\n        const totalTime = frameTimes[frameTimes.length - 1] - frameTimes[0];\n        const averageFrameTime = totalTime / (frameTimes.length - 1);\n        \n        // Should maintain close to 60fps (16.67ms per frame)\n        expect(averageFrameTime).toBeLessThan(20); // Allow some tolerance\n      }\n\n      window.requestAnimationFrame = originalRAF;\n    });\n\n    it('should handle rapid user interactions without lag', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      const field = screen.getByRole('main');\n      const startTime = performance.now();\n\n      // Simulate rapid mouse movements and clicks\n      await act(async () => {\n        for (let i = 0; i < 50; i++) {\n          fireEvent.mouseMove(field, {\n            clientX: 100 + Math.sin(i * 0.1) * 100,\n            clientY: 100 + Math.cos(i * 0.1) * 100\n          });\n          \n          if (i % 5 === 0) {\n            fireEvent.click(field, {\n              clientX: 100 + Math.sin(i * 0.1) * 100,\n              clientY: 100 + Math.cos(i * 0.1) * 100\n            });\n          }\n          \n          await new Promise(resolve => setTimeout(resolve, 10));\n        }\n      });\n\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n\n      // Rapid interactions should be handled smoothly\n      expect(totalTime).toBeLessThan(2000); // Should complete within 2 seconds\n    });\n  });\n\n  describe('Bundle Size and Load Performance', () => {\n    it('should lazy load heavy components', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // Heavy components should not be loaded initially\n      expect(screen.queryByTestId('intelligent-assistant')).not.toBeInTheDocument();\n      expect(screen.queryByTestId('formation-templates')).not.toBeInTheDocument();\n      expect(screen.queryByTestId('analytics-dashboard')).not.toBeInTheDocument();\n\n      // Core board should be loaded\n      expect(screen.getByRole('application')).toBeInTheDocument();\n    });\n\n    it('should preload critical resources', async () => {\n      // This test would verify that critical resources are preloaded\n      // In a real scenario, this would check network requests and resource timing\n      \n      const startTime = performance.now();\n      \n      const testData = createTestData.minimal();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: {\n            players: testData.players,\n            formations: { [testData.formation.id]: testData.formation },\n            activeFormationIds: { home: testData.formation.id },\n            drawings: [],\n            playbook: {},\n            matchState: null,\n            notifications: []\n          }\n        }\n      );\n\n      await waitFor(() => {\n        expect(screen.getByRole('application')).toBeInTheDocument();\n      });\n\n      const endTime = performance.now();\n      const loadTime = endTime - startTime;\n\n      // Critical path should load quickly\n      expect(loadTime).toBeLessThan(500);\n    });\n  });\n\n  describe('Optimization Effectiveness', () => {\n    it('should show performance improvements with optimizations enabled', async () => {\n      const largeDataset = createTestData.performance(300);\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      // Test without optimizations\n      const startTimeUnoptimized = performance.now();\n      \n      const { unmount: unmountUnoptimized } = renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: {\n            players: largeDataset.players,\n            formations: { [largeDataset.formation.id]: largeDataset.formation },\n            activeFormationIds: { home: largeDataset.formation.id },\n            drawings: [],\n            playbook: {},\n            matchState: null,\n            notifications: []\n          },\n          initialUIState: {\n            isLoading: false,\n            selectedTool: 'select',\n            drawingTool: 'select',\n            drawingColor: '#3b82f6',\n            drawings: [],\n            activePlaybookItemId: null,\n            activeStepIndex: null,\n            isAnimating: false,\n            collaborationMode: false,\n            presentationMode: false,\n            // Disable optimizations\n            performanceMode: false\n          }\n        }\n      );\n\n      await waitFor(() => {\n        expect(screen.getByRole('application')).toBeInTheDocument();\n      });\n\n      const endTimeUnoptimized = performance.now();\n      const unoptimizedTime = endTimeUnoptimized - startTimeUnoptimized;\n      \n      unmountUnoptimized();\n\n      // Test with optimizations\n      const startTimeOptimized = performance.now();\n      \n      const { unmount: unmountOptimized } = renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: {\n            players: largeDataset.players,\n            formations: { [largeDataset.formation.id]: largeDataset.formation },\n            activeFormationIds: { home: largeDataset.formation.id },\n            drawings: [],\n            playbook: {},\n            matchState: null,\n            notifications: []\n          },\n          initialUIState: {\n            isLoading: false,\n            selectedTool: 'select',\n            drawingTool: 'select',\n            drawingColor: '#3b82f6',\n            drawings: [],\n            activePlaybookItemId: null,\n            activeStepIndex: null,\n            isAnimating: false,\n            collaborationMode: false,\n            presentationMode: false,\n            // Enable optimizations\n            performanceMode: true\n          }\n        }\n      );\n\n      await waitFor(() => {\n        expect(screen.getByRole('application')).toBeInTheDocument();\n      });\n\n      const endTimeOptimized = performance.now();\n      const optimizedTime = endTimeOptimized - startTimeOptimized;\n      \n      unmountOptimized();\n\n      // Optimized version should be faster (allow some variance)\n      const improvement = (unoptimizedTime - optimizedTime) / unoptimizedTime;\n      expect(improvement).toBeGreaterThan(-0.5); // Should not be significantly slower\n    });\n  });\n});"
/**\n * Comprehensive Cross-Platform Mobile Testing Framework\n * Tests mobile functionality across iOS, Android, tablets, and desktop\n */\n\nimport React from 'react';\nimport { render, screen, fireEvent, waitFor, act } from '@testing-library/react';\nimport { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport userEvent from '@testing-library/user-event';\nimport '@testing-library/jest-dom';\n\n// Import mobile components and utilities\nimport { UnifiedTacticsBoard } from '../../components/tactics/UnifiedTacticsBoard';\nimport MobileNavigation from '../../components/mobile/MobileNavigation';\nimport MobilePlayerToken from '../../components/mobile/MobilePlayerToken';\nimport { useMobileCapabilities, useTouchGestures } from '../../utils/mobileOptimizations';\nimport { useHapticFeedback, useDeviceOrientation, useScreenOrientation } from '../../utils/mobileFeatures';\nimport { usePWA, useOfflineData } from '../../utils/pwaUtils';\n\n// Mock mobile APIs\nconst mockVibrate = vi.fn();\nconst mockGetBattery = vi.fn();\nconst mockRequestPermission = vi.fn();\nconst mockScreenOrientation = {\n  lock: vi.fn(),\n  unlock: vi.fn(),\n  type: 'portrait-primary',\n};\n\n// Device simulation utilities\nclass DeviceSimulator {\n  static simulateDevice(deviceType: 'mobile' | 'tablet' | 'desktop', platform: 'ios' | 'android' | 'desktop' = 'android') {\n    const configs = {\n      mobile: {\n        ios: {\n          userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15',\n          viewport: { width: 375, height: 812 },\n          touchEvents: true,\n          maxTouchPoints: 5,\n          standalone: false,\n          vibrate: true,\n        },\n        android: {\n          userAgent: 'Mozilla/5.0 (Linux; Android 12; SM-G991B) AppleWebKit/537.36',\n          viewport: { width: 360, height: 740 },\n          touchEvents: true,\n          maxTouchPoints: 10,\n          standalone: false,\n          vibrate: true,\n        },\n      },\n      tablet: {\n        ios: {\n          userAgent: 'Mozilla/5.0 (iPad; CPU OS 15_0 like Mac OS X) AppleWebKit/605.1.15',\n          viewport: { width: 1024, height: 1366 },\n          touchEvents: true,\n          maxTouchPoints: 5,\n          standalone: false,\n          vibrate: false,\n        },\n        android: {\n          userAgent: 'Mozilla/5.0 (Linux; Android 12; SM-T870) AppleWebKit/537.36',\n          viewport: { width: 1200, height: 1920 },\n          touchEvents: true,\n          maxTouchPoints: 10,\n          standalone: false,\n          vibrate: true,\n        },\n      },\n      desktop: {\n        desktop: {\n          userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',\n          viewport: { width: 1920, height: 1080 },\n          touchEvents: false,\n          maxTouchPoints: 0,\n          standalone: false,\n          vibrate: false,\n        },\n      },\n    };\n\n    const config = configs[deviceType][platform];\n\n    // Mock navigator properties\n    Object.defineProperty(window.navigator, 'userAgent', {\n      value: config.userAgent,\n      configurable: true,\n    });\n\n    Object.defineProperty(window.navigator, 'maxTouchPoints', {\n      value: config.maxTouchPoints,\n      configurable: true,\n    });\n\n    Object.defineProperty(window.navigator, 'standalone', {\n      value: config.standalone,\n      configurable: true,\n    });\n\n    // Mock vibrate API\n    if (config.vibrate) {\n      Object.defineProperty(window.navigator, 'vibrate', {\n        value: mockVibrate,\n        configurable: true,\n      });\n    }\n\n    // Mock touch events\n    if (config.touchEvents) {\n      Object.defineProperty(window, 'ontouchstart', {\n        value: {},\n        configurable: true,\n      });\n    }\n\n    // Mock screen properties\n    Object.defineProperty(window.screen, 'width', {\n      value: config.viewport.width,\n      configurable: true,\n    });\n\n    Object.defineProperty(window.screen, 'height', {\n      value: config.viewport.height,\n      configurable: true,\n    });\n\n    // Mock window dimensions\n    Object.defineProperty(window, 'innerWidth', {\n      value: config.viewport.width,\n      configurable: true,\n    });\n\n    Object.defineProperty(window, 'innerHeight', {\n      value: config.viewport.height,\n      configurable: true,\n    });\n\n    // Mock device pixel ratio\n    Object.defineProperty(window, 'devicePixelRatio', {\n      value: deviceType === 'mobile' ? 2 : 1,\n      configurable: true,\n    });\n\n    return config;\n  }\n\n  static simulateNetworkCondition(type: 'online' | 'offline' | 'slow') {\n    Object.defineProperty(navigator, 'onLine', {\n      value: type !== 'offline',\n      configurable: true,\n    });\n\n    if (type === 'slow') {\n      Object.defineProperty(navigator, 'connection', {\n        value: {\n          effectiveType: '2g',\n          downlink: 0.25,\n          rtt: 2000,\n          saveData: true,\n        },\n        configurable: true,\n      });\n    } else {\n      Object.defineProperty(navigator, 'connection', {\n        value: {\n          effectiveType: '4g',\n          downlink: 10,\n          rtt: 50,\n          saveData: false,\n        },\n        configurable: true,\n      });\n    }\n  }\n\n  static simulateBattery(level: number, charging: boolean = false) {\n    mockGetBattery.mockResolvedValue({\n      level,\n      charging,\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n    });\n\n    Object.defineProperty(navigator, 'getBattery', {\n      value: mockGetBattery,\n      configurable: true,\n    });\n  }\n\n  static simulateOrientation(type: 'portrait' | 'landscape') {\n    const orientation = type === 'portrait' ? 'portrait-primary' : 'landscape-primary';\n    \n    Object.defineProperty(window.screen, 'orientation', {\n      value: {\n        ...mockScreenOrientation,\n        type: orientation,\n      },\n      configurable: true,\n    });\n\n    // Trigger orientation change event\n    const event = new Event('orientationchange');\n    window.dispatchEvent(event);\n  }\n}\n\n// Touch simulation utilities\nclass TouchSimulator {\n  static createTouchEvent(type: string, touches: Array<{ x: number; y: number; id?: number }>) {\n    const touchList = touches.map((touch, index) => ({\n      identifier: touch.id || index,\n      clientX: touch.x,\n      clientY: touch.y,\n      pageX: touch.x,\n      pageY: touch.y,\n      screenX: touch.x,\n      screenY: touch.y,\n      target: document.body,\n    }));\n\n    return new TouchEvent(type, {\n      touches: touchList,\n      changedTouches: touchList,\n      targetTouches: touchList,\n    });\n  }\n\n  static simulateTap(element: HTMLElement, position: { x: number; y: number }) {\n    const touchStart = this.createTouchEvent('touchstart', [position]);\n    const touchEnd = this.createTouchEvent('touchend', [position]);\n\n    fireEvent(element, touchStart);\n    \n    setTimeout(() => {\n      fireEvent(element, touchEnd);\n    }, 100);\n  }\n\n  static simulateSwipe(element: HTMLElement, start: { x: number; y: number }, end: { x: number; y: number }, duration: number = 300) {\n    const touchStart = this.createTouchEvent('touchstart', [start]);\n    const touchMove = this.createTouchEvent('touchmove', [end]);\n    const touchEnd = this.createTouchEvent('touchend', [end]);\n\n    fireEvent(element, touchStart);\n    \n    setTimeout(() => {\n      fireEvent(element, touchMove);\n    }, duration / 2);\n    \n    setTimeout(() => {\n      fireEvent(element, touchEnd);\n    }, duration);\n  }\n\n  static simulatePinch(element: HTMLElement, center: { x: number; y: number }, scale: number) {\n    const distance = 100;\n    const newDistance = distance * scale;\n    \n    const touch1Start = { x: center.x - distance / 2, y: center.y };\n    const touch2Start = { x: center.x + distance / 2, y: center.y };\n    const touch1End = { x: center.x - newDistance / 2, y: center.y };\n    const touch2End = { x: center.x + newDistance / 2, y: center.y };\n\n    const touchStart = this.createTouchEvent('touchstart', [touch1Start, touch2Start]);\n    const touchMove = this.createTouchEvent('touchmove', [touch1End, touch2End]);\n    const touchEnd = this.createTouchEvent('touchend', []);\n\n    fireEvent(element, touchStart);\n    fireEvent(element, touchMove);\n    fireEvent(element, touchEnd);\n  }\n}\n\n// Test suites\ndescribe('Cross-Platform Mobile Testing', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n    \n    // Mock PWA APIs\n    Object.defineProperty(window, 'caches', {\n      value: {\n        open: vi.fn().mockResolvedValue({\n          match: vi.fn(),\n          put: vi.fn(),\n          delete: vi.fn(),\n          keys: vi.fn().mockResolvedValue([]),\n        }),\n        keys: vi.fn().mockResolvedValue([]),\n        delete: vi.fn(),\n      },\n      configurable: true,\n    });\n\n    // Mock IndexedDB\n    Object.defineProperty(window, 'indexedDB', {\n      value: {\n        open: vi.fn().mockImplementation(() => ({\n          onsuccess: null,\n          onerror: null,\n          result: {\n            createObjectStore: vi.fn(),\n            transaction: vi.fn().mockReturnValue({\n              objectStore: vi.fn().mockReturnValue({\n                add: vi.fn(),\n                put: vi.fn(),\n                get: vi.fn(),\n                getAll: vi.fn(),\n                delete: vi.fn(),\n              }),\n              complete: Promise.resolve(),\n            }),\n          },\n        })),\n        databases: vi.fn().mockResolvedValue([]),\n      },\n      configurable: true,\n    });\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  describe('iOS Mobile Testing', () => {\n    beforeEach(() => {\n      DeviceSimulator.simulateDevice('mobile', 'ios');\n    });\n\n    it('should detect iOS mobile capabilities correctly', () => {\n      const TestComponent = () => {\n        const capabilities = useMobileCapabilities();\n        return (\n          <div data-testid=\"capabilities\">\n            <span data-testid=\"is-mobile\">{capabilities.isMobile.toString()}</span>\n            <span data-testid=\"is-ios\">{capabilities.isIOS.toString()}</span>\n            <span data-testid=\"supports-touch\">{capabilities.supportsTouchEvents.toString()}</span>\n            <span data-testid=\"has-haptic\">{capabilities.hasHapticFeedback.toString()}</span>\n          </div>\n        );\n      };\n\n      render(<TestComponent />);\n\n      expect(screen.getByTestId('is-mobile')).toHaveTextContent('true');\n      expect(screen.getByTestId('is-ios')).toHaveTextContent('true');\n      expect(screen.getByTestId('supports-touch')).toHaveTextContent('true');\n      expect(screen.getByTestId('has-haptic')).toHaveTextContent('true');\n    });\n\n    it('should handle touch gestures on iOS', async () => {\n      const onTap = vi.fn();\n      const onSwipe = vi.fn();\n\n      const TestComponent = () => {\n        const elementRef = React.useRef<HTMLDivElement>(null);\n        \n        useTouchGestures(elementRef, {\n          onTap,\n          onSwipe,\n        });\n\n        return <div ref={elementRef} data-testid=\"touch-element\">Touch me</div>;\n      };\n\n      render(<TestComponent />);\n      const element = screen.getByTestId('touch-element');\n\n      // Simulate tap\n      TouchSimulator.simulateTap(element, { x: 100, y: 100 });\n      \n      await waitFor(() => {\n        expect(onTap).toHaveBeenCalled();\n      });\n\n      // Simulate swipe\n      TouchSimulator.simulateSwipe(element, { x: 50, y: 100 }, { x: 150, y: 100 });\n      \n      await waitFor(() => {\n        expect(onSwipe).toHaveBeenCalledWith(\n          expect.any(TouchEvent),\n          'right',\n          expect.any(Number)\n        );\n      });\n    });\n\n    it('should trigger haptic feedback on iOS', async () => {\n      const TestComponent = () => {\n        const { triggerHaptic } = useHapticFeedback();\n        \n        return (\n          <button \n            data-testid=\"haptic-button\"\n            onClick={() => triggerHaptic('LIGHT_TAP')}\n          >\n            Trigger Haptic\n          </button>\n        );\n      };\n\n      render(<TestComponent />);\n      const button = screen.getByTestId('haptic-button');\n\n      await userEvent.click(button);\n\n      expect(mockVibrate).toHaveBeenCalledWith([10]);\n    });\n\n    it('should handle orientation changes on iOS', async () => {\n      const onOrientationChange = vi.fn();\n\n      const TestComponent = () => {\n        const { orientation } = useScreenOrientation();\n        \n        React.useEffect(() => {\n          onOrientationChange(orientation);\n        }, [orientation]);\n\n        return <div data-testid=\"orientation\">{orientation}</div>;\n      };\n\n      render(<TestComponent />);\n\n      // Start with portrait\n      expect(screen.getByTestId('orientation')).toHaveTextContent('portrait-primary');\n\n      // Simulate orientation change to landscape\n      act(() => {\n        DeviceSimulator.simulateOrientation('landscape');\n      });\n\n      await waitFor(() => {\n        expect(onOrientationChange).toHaveBeenCalledWith('landscape-primary');\n      });\n    });\n  });\n\n  describe('Android Mobile Testing', () => {\n    beforeEach(() => {\n      DeviceSimulator.simulateDevice('mobile', 'android');\n    });\n\n    it('should detect Android mobile capabilities correctly', () => {\n      const TestComponent = () => {\n        const capabilities = useMobileCapabilities();\n        return (\n          <div data-testid=\"capabilities\">\n            <span data-testid=\"is-mobile\">{capabilities.isMobile.toString()}</span>\n            <span data-testid=\"is-android\">{capabilities.isAndroid.toString()}</span>\n            <span data-testid=\"max-touch-points\">{capabilities.maxTouchPoints}</span>\n          </div>\n        );\n      };\n\n      render(<TestComponent />);\n\n      expect(screen.getByTestId('is-mobile')).toHaveTextContent('true');\n      expect(screen.getByTestId('is-android')).toHaveTextContent('true');\n      expect(screen.getByTestId('max-touch-points')).toHaveTextContent('10');\n    });\n\n    it('should handle multi-touch gestures on Android', async () => {\n      const onPinch = vi.fn();\n\n      const TestComponent = () => {\n        const elementRef = React.useRef<HTMLDivElement>(null);\n        \n        useTouchGestures(elementRef, {\n          onPinch,\n        });\n\n        return <div ref={elementRef} data-testid=\"pinch-element\">Pinch me</div>;\n      };\n\n      render(<TestComponent />);\n      const element = screen.getByTestId('pinch-element');\n\n      // Simulate pinch gesture\n      TouchSimulator.simulatePinch(element, { x: 200, y: 200 }, 1.5);\n      \n      await waitFor(() => {\n        expect(onPinch).toHaveBeenCalledWith(\n          expect.any(TouchEvent),\n          expect.any(Number)\n        );\n      });\n    });\n  });\n\n  describe('Tablet Testing', () => {\n    beforeEach(() => {\n      DeviceSimulator.simulateDevice('tablet', 'android');\n    });\n\n    it('should detect tablet capabilities correctly', () => {\n      const TestComponent = () => {\n        const capabilities = useMobileCapabilities();\n        return (\n          <div data-testid=\"capabilities\">\n            <span data-testid=\"is-tablet\">{capabilities.isTablet.toString()}</span>\n            <span data-testid=\"viewport-width\">{capabilities.viewportWidth}</span>\n          </div>\n        );\n      };\n\n      render(<TestComponent />);\n\n      expect(screen.getByTestId('is-tablet')).toHaveTextContent('true');\n      expect(screen.getByTestId('viewport-width')).toHaveTextContent('1200');\n    });\n\n    it('should adapt UI layout for tablet', () => {\n      const mockProps = {\n        formation: undefined,\n        players: [],\n        onPlayerSelect: vi.fn(),\n        onPlayerMove: vi.fn(),\n        onPlayerLongPress: vi.fn(),\n      };\n\n      render(<UnifiedTacticsBoard {...mockProps} />);\n\n      // Should show sidebars on tablet\n      expect(document.querySelector('.mobile-drawer')).not.toBeInTheDocument();\n    });\n  });\n\n  describe('Desktop Testing', () => {\n    beforeEach(() => {\n      DeviceSimulator.simulateDevice('desktop');\n    });\n\n    it('should detect desktop capabilities correctly', () => {\n      const TestComponent = () => {\n        const capabilities = useMobileCapabilities();\n        return (\n          <div data-testid=\"capabilities\">\n            <span data-testid=\"is-mobile\">{capabilities.isMobile.toString()}</span>\n            <span data-testid=\"supports-touch\">{capabilities.supportsTouchEvents.toString()}</span>\n            <span data-testid=\"supports-hover\">{capabilities.supportsHover.toString()}</span>\n          </div>\n        );\n      };\n\n      render(<TestComponent />);\n\n      expect(screen.getByTestId('is-mobile')).toHaveTextContent('false');\n      expect(screen.getByTestId('supports-touch')).toHaveTextContent('false');\n      expect(screen.getByTestId('supports-hover')).toHaveTextContent('true');\n    });\n\n    it('should use mouse interactions on desktop', async () => {\n      const onSelect = vi.fn();\n      const mockPlayer = {\n        id: '1',\n        name: 'Test Player',\n        position: 'ST',\n        jerseyNumber: 10,\n      };\n\n      render(\n        <MobilePlayerToken\n          player={mockPlayer}\n          position={{ x: 100, y: 100 }}\n          isSelected={false}\n          isDragging={false}\n          onSelect={onSelect}\n          onMove={vi.fn()}\n          onLongPress={vi.fn()}\n          onDragStart={vi.fn()}\n          onDragEnd={vi.fn()}\n          fieldBounds={new DOMRect(0, 0, 800, 600)}\n        />\n      );\n\n      const playerToken = screen.getByRole('button');\n      \n      await userEvent.click(playerToken);\n      \n      expect(onSelect).toHaveBeenCalledWith(mockPlayer, expect.any(Object));\n    });\n  });\n\n  describe('Network Conditions Testing', () => {\n    it('should adapt to offline condition', async () => {\n      DeviceSimulator.simulateNetworkCondition('offline');\n\n      const TestComponent = () => {\n        const { isOffline } = useOfflineData();\n        return <div data-testid=\"network-status\">{isOffline ? 'offline' : 'online'}</div>;\n      };\n\n      render(<TestComponent />);\n\n      expect(screen.getByTestId('network-status')).toHaveTextContent('offline');\n    });\n\n    it('should adapt to slow network condition', () => {\n      DeviceSimulator.simulateNetworkCondition('slow');\n\n      const TestComponent = () => {\n        const capabilities = useMobileCapabilities();\n        return <div data-testid=\"connection-type\">{capabilities.connectionType}</div>;\n      };\n\n      render(<TestComponent />);\n\n      expect(screen.getByTestId('connection-type')).toHaveTextContent('slow');\n    });\n  });\n\n  describe('Battery Optimization Testing', () => {\n    it('should reduce performance on low battery', async () => {\n      DeviceSimulator.simulateBattery(0.15, false); // 15% battery, not charging\n\n      const TestComponent = () => {\n        const capabilities = useMobileCapabilities();\n        return (\n          <div data-testid=\"battery-info\">\n            <span data-testid=\"battery-level\">{capabilities.batteryLevel}</span>\n            <span data-testid=\"is-charging\">{capabilities.isCharging?.toString()}</span>\n          </div>\n        );\n      };\n\n      render(<TestComponent />);\n\n      await waitFor(() => {\n        expect(screen.getByTestId('battery-level')).toHaveTextContent('15');\n        expect(screen.getByTestId('is-charging')).toHaveTextContent('false');\n      });\n    });\n  });\n\n  describe('PWA Functionality Testing', () => {\n    it('should detect PWA installation capability', () => {\n      const TestComponent = () => {\n        const { isInstallable, isSupported } = usePWA();\n        return (\n          <div data-testid=\"pwa-status\">\n            <span data-testid=\"is-installable\">{isInstallable.toString()}</span>\n            <span data-testid=\"is-supported\">{isSupported.toString()}</span>\n          </div>\n        );\n      };\n\n      render(<TestComponent />);\n\n      expect(screen.getByTestId('is-supported')).toHaveTextContent('true');\n    });\n\n    it('should handle offline data storage', async () => {\n      const TestComponent = () => {\n        const { storeOfflineData } = useOfflineData();\n        \n        const handleStore = async () => {\n          await storeOfflineData('formation', { id: '1', name: 'Test Formation' });\n        };\n\n        return (\n          <button data-testid=\"store-button\" onClick={handleStore}>\n            Store Offline Data\n          </button>\n        );\n      };\n\n      render(<TestComponent />);\n      const storeButton = screen.getByTestId('store-button');\n\n      await userEvent.click(storeButton);\n\n      // Verify that offline storage was attempted\n      // (In real implementation, this would interact with IndexedDB)\n      expect(storeButton).toBeInTheDocument();\n    });\n  });\n\n  describe('Accessibility Testing', () => {\n    it('should provide proper ARIA labels for mobile elements', () => {\n      const mockPlayer = {\n        id: '1',\n        name: 'Test Player',\n        position: 'ST',\n        jerseyNumber: 10,\n        rating: 85,\n      };\n\n      render(\n        <MobilePlayerToken\n          player={mockPlayer}\n          position={{ x: 100, y: 100 }}\n          isSelected={false}\n          isDragging={false}\n          onSelect={vi.fn()}\n          onMove={vi.fn()}\n          onLongPress={vi.fn()}\n          onDragStart={vi.fn()}\n          onDragEnd={vi.fn()}\n          fieldBounds={new DOMRect(0, 0, 800, 600)}\n        />\n      );\n\n      const playerToken = screen.getByRole('button');\n      \n      expect(playerToken).toHaveAttribute('aria-label', 'Player Test Player (ST) - 85 rating');\n      expect(playerToken).toHaveAttribute('tabIndex', '0');\n    });\n\n    it('should support keyboard navigation on non-touch devices', async () => {\n      DeviceSimulator.simulateDevice('desktop');\n      \n      const onSelect = vi.fn();\n      const mockPlayer = {\n        id: '1',\n        name: 'Test Player',\n        position: 'ST',\n        jerseyNumber: 10,\n      };\n\n      render(\n        <MobilePlayerToken\n          player={mockPlayer}\n          position={{ x: 100, y: 100 }}\n          isSelected={false}\n          isDragging={false}\n          onSelect={onSelect}\n          onMove={vi.fn()}\n          onLongPress={vi.fn()}\n          onDragStart={vi.fn()}\n          onDragEnd={vi.fn()}\n          fieldBounds={new DOMRect(0, 0, 800, 600)}\n        />\n      );\n\n      const playerToken = screen.getByRole('button');\n      \n      // Test keyboard navigation\n      playerToken.focus();\n      expect(playerToken).toHaveFocus();\n      \n      // Test Enter key activation\n      await userEvent.keyboard('{Enter}');\n      expect(onSelect).toHaveBeenCalled();\n    });\n  });\n\n  describe('Performance Testing', () => {\n    it('should render efficiently on mobile devices', () => {\n      DeviceSimulator.simulateDevice('mobile', 'android');\n      \n      const startTime = performance.now();\n      \n      const mockProps = {\n        formation: undefined,\n        players: [],\n        onPlayerSelect: vi.fn(),\n        onPlayerMove: vi.fn(),\n        onPlayerLongPress: vi.fn(),\n      };\n\n      render(<UnifiedTacticsBoard {...mockProps} />);\n      \n      const renderTime = performance.now() - startTime;\n      \n      // Should render within 100ms on mobile\n      expect(renderTime).toBeLessThan(100);\n    });\n\n    it('should throttle touch events for performance', async () => {\n      DeviceSimulator.simulateDevice('mobile', 'android');\n      \n      const onMove = vi.fn();\n      const mockPlayer = {\n        id: '1',\n        name: 'Test Player',\n        position: 'ST',\n        jerseyNumber: 10,\n      };\n\n      render(\n        <MobilePlayerToken\n          player={mockPlayer}\n          position={{ x: 100, y: 100 }}\n          isSelected={false}\n          isDragging={false}\n          onSelect={vi.fn()}\n          onMove={onMove}\n          onLongPress={vi.fn()}\n          onDragStart={vi.fn()}\n          onDragEnd={vi.fn()}\n          fieldBounds={new DOMRect(0, 0, 800, 600)}\n        />\n      );\n\n      const playerToken = screen.getByRole('button');\n      \n      // Simulate rapid touch move events\n      for (let i = 0; i < 10; i++) {\n        TouchSimulator.simulateSwipe(playerToken, { x: 100 + i, y: 100 }, { x: 110 + i, y: 100 }, 10);\n      }\n      \n      // Should throttle events, not call onMove 10 times\n      await waitFor(() => {\n        expect(onMove).toHaveBeenCalledTimes(1);\n      });\n    });\n  });\n});\n\n// Export utilities for other tests\nexport { DeviceSimulator, TouchSimulator };"
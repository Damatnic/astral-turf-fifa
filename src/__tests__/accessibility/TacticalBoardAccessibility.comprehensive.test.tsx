import React from 'react';\nimport {\n  renderWithProviders,\n  createTestData,\n  createMockProps,\n  vi,\n  expect,\n  describe,\n  it,\n  beforeEach,\n  afterEach,\n  screen,\n  fireEvent,\n  waitFor,\n  userEvent\n} from '../../utils/comprehensive-test-providers';\nimport { axe, toHaveNoViolations } from 'jest-axe';\nimport { UnifiedTacticsBoard } from '../../../components/tactics/UnifiedTacticsBoard';\nimport PlayerDisplaySettings from '../../../components/tactics/PlayerDisplaySettings';\nimport PositionalBench from '../../../components/tactics/PositionalBench';\n\n// Extend Jest matchers\nexpect.extend(toHaveNoViolations);\n\n/**\n * Comprehensive accessibility testing suite for tactical board components\n * Tests WCAG 2.1 AA compliance, keyboard navigation, screen reader support\n */\n\ndescribe('Tactical Board Accessibility - Comprehensive Test Suite', () => {\n  let user: ReturnType<typeof userEvent.setup>;\n\n  beforeEach(() => {\n    user = userEvent.setup();\n\n    // Mock screen reader announcements\n    global.speechSynthesis = {\n      speak: vi.fn(),\n      cancel: vi.fn(),\n      pause: vi.fn(),\n      resume: vi.fn(),\n      getVoices: vi.fn(() => []),\n      speaking: false,\n      pending: false,\n      paused: false,\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n      dispatchEvent: vi.fn()\n    } as any;\n\n    // Mock aria-live region updates\n    const mockAriaLive = document.createElement('div');\n    mockAriaLive.setAttribute('aria-live', 'polite');\n    mockAriaLive.setAttribute('aria-atomic', 'true');\n    mockAriaLive.className = 'sr-only';\n    document.body.appendChild(mockAriaLive);\n  });\n\n  afterEach(() => {\n    vi.clearAllMocks();\n    // Clean up aria-live regions\n    document.querySelectorAll('.sr-only').forEach(el => el.remove());\n  });\n\n  describe('UnifiedTacticsBoard Accessibility', () => {\n    it('should have no accessibility violations (WCAG 2.1 AA)', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      const { container } = renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      await waitFor(() => {\n        expect(container.querySelector('[role=\"application\"]')).toBeInTheDocument();\n      });\n\n      // Run axe accessibility tests\n      const results = await axe(container, {\n        rules: {\n          // Focus on WCAG 2.1 AA compliance\n          'color-contrast': { enabled: true },\n          'keyboard-navigation': { enabled: true },\n          'focus-management': { enabled: true },\n          'aria-required-attr': { enabled: true },\n          'aria-valid-attr': { enabled: true },\n          'aria-allowed-attr': { enabled: true },\n          'label': { enabled: true },\n          'landmark-unique': { enabled: true },\n          'region': { enabled: true }\n        }\n      });\n\n      expect(results).toHaveNoViolations();\n    });\n\n    it('should have proper semantic structure', () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // Check main landmarks\n      expect(screen.getByRole('application')).toBeInTheDocument();\n      expect(screen.getByRole('main')).toBeInTheDocument();\n      \n      // Check for complementary regions (sidebars)\n      const complementaryRegions = screen.getAllByRole('complementary');\n      expect(complementaryRegions.length).toBeGreaterThanOrEqual(1);\n\n      // Check application has proper label\n      const app = screen.getByRole('application');\n      expect(app).toHaveAttribute('aria-label', 'Soccer Tactics Board');\n      expect(app).toHaveAttribute('aria-live', 'polite');\n    });\n\n    it('should support comprehensive keyboard navigation', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      const app = screen.getByRole('application');\n      \n      // Tab into application\n      await user.tab();\n      expect(document.activeElement).toBeDefined();\n\n      // Test arrow key navigation\n      await user.keyboard('{ArrowRight}');\n      await user.keyboard('{ArrowDown}');\n      await user.keyboard('{ArrowLeft}');\n      await user.keyboard('{ArrowUp}');\n\n      // Test action keys\n      await user.keyboard('{Enter}');\n      await user.keyboard(' '); // Space\n      await user.keyboard('{Escape}');\n\n      // Should maintain focus management\n      expect(document.activeElement).toBeDefined();\n      expect(document.activeElement).not.toBe(document.body);\n    });\n\n    it('should provide screen reader announcements for state changes', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      const { container } = renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // Check for screen reader only content\n      const srOnlyElement = container.querySelector('.sr-only');\n      expect(srOnlyElement).toBeInTheDocument();\n      expect(srOnlyElement).toHaveAttribute('aria-live', 'polite');\n      expect(srOnlyElement).toHaveAttribute('aria-atomic', 'true');\n    });\n\n    it('should support high contrast mode', () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      // Mock high contrast media query\n      Object.defineProperty(window, 'matchMedia', {\n        writable: true,\n        value: vi.fn().mockImplementation(query => ({\n          matches: query.includes('prefers-contrast: high'),\n          media: query,\n          onchange: null,\n          addListener: vi.fn(),\n          removeListener: vi.fn(),\n          addEventListener: vi.fn(),\n          removeEventListener: vi.fn(),\n          dispatchEvent: vi.fn(),\n        })),\n      });\n\n      const { container } = renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // Should adapt to high contrast mode\n      expect(container.querySelector('[role=\"application\"]')).toBeInTheDocument();\n    });\n\n    it('should support reduced motion preferences', () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      // Mock reduced motion preference\n      Object.defineProperty(window, 'matchMedia', {\n        writable: true,\n        value: vi.fn().mockImplementation(query => ({\n          matches: query.includes('prefers-reduced-motion: reduce'),\n          media: query,\n          onchange: null,\n          addListener: vi.fn(),\n          removeListener: vi.fn(),\n          addEventListener: vi.fn(),\n          removeEventListener: vi.fn(),\n          dispatchEvent: vi.fn(),\n        })),\n      });\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // Should respect reduced motion preference\n      expect(screen.getByRole('application')).toBeInTheDocument();\n    });\n\n    it('should handle focus management in modals', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // Simulate opening a modal (if available)\n      const modalTrigger = screen.queryByRole('button', { name: /formation templates|settings|options/i });\n      if (modalTrigger) {\n        await user.click(modalTrigger);\n        \n        await waitFor(() => {\n          // Focus should move to modal\n          const modal = screen.queryByRole('dialog');\n          if (modal) {\n            expect(modal).toBeInTheDocument();\n            expect(modal).toHaveAttribute('aria-modal', 'true');\n          }\n        });\n\n        // Test escape key to close modal\n        await user.keyboard('{Escape}');\n        \n        // Focus should return to trigger\n        await waitFor(() => {\n          expect(modalTrigger).toHaveFocus();\n        });\n      }\n    });\n  });\n\n  describe('PlayerDisplaySettings Accessibility', () => {\n    it('should have no accessibility violations', async () => {\n      const mockProps = createMockProps.playerDisplaySettings();\n\n      const { container } = renderWithProviders(\n        <PlayerDisplaySettings {...mockProps} />\n      );\n\n      const results = await axe(container);\n      expect(results).toHaveNoViolations();\n    });\n\n    it('should have proper form labels and associations', () => {\n      const mockProps = createMockProps.playerDisplaySettings();\n\n      renderWithProviders(\n        <PlayerDisplaySettings {...mockProps} />\n      );\n\n      // All form controls should have proper labels\n      const checkboxes = screen.getAllByRole('checkbox');\n      checkboxes.forEach(checkbox => {\n        expect(checkbox).toHaveAccessibleName();\n      });\n\n      const selects = screen.getAllByRole('combobox');\n      selects.forEach(select => {\n        expect(select).toHaveAccessibleName();\n      });\n\n      const buttons = screen.getAllByRole('button');\n      buttons.forEach(button => {\n        expect(button).toHaveAccessibleName();\n      });\n    });\n\n    it('should support keyboard navigation through form controls', async () => {\n      const mockProps = createMockProps.playerDisplaySettings();\n\n      renderWithProviders(\n        <PlayerDisplaySettings {...mockProps} />\n      );\n\n      // Tab through all form controls\n      const formControls = [\n        ...screen.getAllByRole('checkbox'),\n        ...screen.getAllByRole('combobox'),\n        ...screen.getAllByRole('button')\n      ];\n\n      for (let i = 0; i < formControls.length; i++) {\n        await user.tab();\n        // Should focus next control in tab order\n        expect(document.activeElement).toBeDefined();\n      }\n    });\n\n    it('should announce changes to screen readers', async () => {\n      const mockProps = createMockProps.playerDisplaySettings();\n\n      renderWithProviders(\n        <PlayerDisplaySettings {...mockProps} />\n      );\n\n      const showNamesCheckbox = screen.getByLabelText(/show player names/i);\n      \n      // Change should trigger aria-live announcement\n      await user.click(showNamesCheckbox);\n      \n      expect(mockProps.onChange).toHaveBeenCalled();\n    });\n\n    it('should provide clear error messages and validation', () => {\n      const mockProps = createMockProps.playerDisplaySettings();\n\n      renderWithProviders(\n        <PlayerDisplaySettings {...mockProps} />\n      );\n\n      // Form should be accessible even with validation errors\n      const formControls = screen.getAllByRole('checkbox');\n      formControls.forEach(control => {\n        expect(control).not.toHaveAttribute('aria-invalid', 'true');\n      });\n    });\n  });\n\n  describe('PositionalBench Accessibility', () => {\n    it('should have no accessibility violations', async () => {\n      const mockProps = createMockProps.positionalBench();\n\n      const { container } = renderWithProviders(\n        <PositionalBench {...mockProps} />\n      );\n\n      const results = await axe(container);\n      expect(results).toHaveNoViolations();\n    });\n\n    it('should have proper list structure and item labels', () => {\n      const testData = createTestData.complete();\n      const mockProps = {\n        ...createMockProps.positionalBench(),\n        players: testData.players.slice(11, 15) // 4 bench players\n      };\n\n      renderWithProviders(\n        <PositionalBench {...mockProps} />\n      );\n\n      // Should have list role\n      const bench = screen.getByRole('list', { name: /substitute players bench|bench/i });\n      expect(bench).toBeInTheDocument();\n\n      // Each player should be a list item\n      const playerItems = screen.getAllByRole('listitem');\n      expect(playerItems.length).toBe(4);\n\n      // Each player item should have accessible name\n      playerItems.forEach(item => {\n        expect(item).toHaveAccessibleName();\n        expect(item).toHaveAttribute('tabindex', '0');\n      });\n    });\n\n    it('should support keyboard navigation between players', async () => {\n      const testData = createTestData.complete();\n      const mockProps = {\n        ...createMockProps.positionalBench(),\n        players: testData.players.slice(11, 15)\n      };\n\n      renderWithProviders(\n        <PositionalBench {...mockProps} />\n      );\n\n      const playerItems = screen.getAllByRole('listitem');\n      \n      // Focus first player\n      playerItems[0].focus();\n      expect(playerItems[0]).toHaveFocus();\n\n      // Navigate with arrow keys\n      await user.keyboard('{ArrowDown}');\n      expect(playerItems[1]).toHaveFocus();\n\n      await user.keyboard('{ArrowDown}');\n      expect(playerItems[2]).toHaveFocus();\n\n      await user.keyboard('{ArrowUp}');\n      expect(playerItems[1]).toHaveFocus();\n    });\n\n    it('should support player selection with keyboard', async () => {\n      const testData = createTestData.complete();\n      const mockProps = {\n        ...createMockProps.positionalBench(),\n        players: testData.players.slice(11, 15)\n      };\n\n      renderWithProviders(\n        <PositionalBench {...mockProps} />\n      );\n\n      const firstPlayer = screen.getAllByRole('listitem')[0];\n      firstPlayer.focus();\n\n      // Select with Enter\n      await user.keyboard('{Enter}');\n      expect(mockProps.onPlayerSelect).toHaveBeenCalledWith(testData.players[11]);\n\n      // Select with Space\n      await user.keyboard(' ');\n      expect(mockProps.onPlayerSelect).toHaveBeenCalledWith(testData.players[11]);\n    });\n\n    it('should announce drag and drop operations', async () => {\n      const testData = createTestData.complete();\n      const mockProps = {\n        ...createMockProps.positionalBench(),\n        players: testData.players.slice(11, 15)\n      };\n\n      renderWithProviders(\n        <PositionalBench {...mockProps} />\n      );\n\n      const firstPlayer = screen.getAllByRole('listitem')[0];\n      \n      // Should have drag and drop instructions\n      expect(firstPlayer).toHaveAttribute('aria-describedby');\n      \n      // Simulate drag start\n      fireEvent.dragStart(firstPlayer);\n      \n      // Should announce drag operation\n      const ariaLive = document.querySelector('[aria-live]');\n      expect(ariaLive).toBeInTheDocument();\n    });\n\n    it('should handle search accessibility', async () => {\n      const testData = createTestData.complete();\n      const mockProps = {\n        ...createMockProps.positionalBench(),\n        players: testData.players.slice(11, 15),\n        searchable: true\n      };\n\n      renderWithProviders(\n        <PositionalBench {...mockProps} searchable={true} />\n      );\n\n      const searchInput = screen.getByRole('searchbox', { name: /search players/i });\n      expect(searchInput).toBeInTheDocument();\n      expect(searchInput).toHaveAccessibleName();\n\n      // Should have proper ARIA attributes\n      expect(searchInput).toHaveAttribute('aria-label');\n      \n      // Test search functionality\n      await user.type(searchInput, 'test');\n      \n      // Should announce search results\n      await waitFor(() => {\n        const resultsRegion = screen.queryByRole('region', { name: /search results/i });\n        if (resultsRegion) {\n          expect(resultsRegion).toHaveAttribute('aria-live', 'polite');\n        }\n      });\n    });\n  });\n\n  describe('Focus Management', () => {\n    it('should maintain focus within modal dialogs', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // Find any button that might open a modal\n      const buttons = screen.getAllByRole('button');\n      const modalTrigger = buttons.find(button => \n        button.textContent?.toLowerCase().includes('settings') ||\n        button.textContent?.toLowerCase().includes('templates') ||\n        button.textContent?.toLowerCase().includes('options')\n      );\n\n      if (modalTrigger) {\n        await user.click(modalTrigger);\n        \n        // Check if modal opened\n        const modal = screen.queryByRole('dialog');\n        if (modal) {\n          // Tab should cycle within modal\n          const focusableElements = modal.querySelectorAll(\n            'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n          );\n          \n          if (focusableElements.length > 1) {\n            // Focus should be trapped within modal\n            const firstElement = focusableElements[0] as HTMLElement;\n            const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;\n            \n            lastElement.focus();\n            await user.tab();\n            expect(firstElement).toHaveFocus();\n            \n            await user.tab({ shift: true });\n            expect(lastElement).toHaveFocus();\n          }\n        }\n      }\n    });\n\n    it('should restore focus after modal close', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      const buttons = screen.getAllByRole('button');\n      const modalTrigger = buttons[0];\n      \n      // Focus and activate trigger\n      modalTrigger.focus();\n      await user.click(modalTrigger);\n      \n      // Close modal (simulate escape or close button)\n      await user.keyboard('{Escape}');\n      \n      // Focus should return to trigger\n      await waitFor(() => {\n        expect(modalTrigger).toHaveFocus();\n      });\n    });\n\n    it('should skip hidden elements in tab order', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // Tab through visible elements\n      for (let i = 0; i < 10; i++) {\n        await user.tab();\n        \n        const activeElement = document.activeElement as HTMLElement;\n        \n        // Should not focus hidden elements\n        expect(activeElement.style.display).not.toBe('none');\n        expect(activeElement.style.visibility).not.toBe('hidden');\n        expect(activeElement.getAttribute('aria-hidden')).not.toBe('true');\n        expect(activeElement.getAttribute('tabindex')).not.toBe('-1');\n      }\n    });\n  });\n\n  describe('Screen Reader Support', () => {\n    it('should provide meaningful accessible names', () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // Main application should have accessible name\n      const app = screen.getByRole('application');\n      expect(app).toHaveAccessibleName();\n\n      // Main content should have accessible name\n      const main = screen.getByRole('main');\n      expect(main).toHaveAccessibleName();\n\n      // Interactive elements should have accessible names\n      const buttons = screen.getAllByRole('button');\n      buttons.forEach(button => {\n        expect(button).toHaveAccessibleName();\n      });\n    });\n\n    it('should provide live region updates', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      const { container } = renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // Should have aria-live regions\n      const liveRegions = container.querySelectorAll('[aria-live]');\n      expect(liveRegions.length).toBeGreaterThan(0);\n\n      liveRegions.forEach(region => {\n        expect(region).toHaveAttribute('aria-live');\n        expect(['polite', 'assertive', 'off']).toContain(\n          region.getAttribute('aria-live')\n        );\n      });\n    });\n\n    it('should provide status updates for user actions', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      const { container } = renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // Simulate user action\n      const field = screen.getByRole('main');\n      await user.click(field);\n\n      // Should update screen reader content\n      const srOnlyContent = container.querySelector('.sr-only');\n      expect(srOnlyContent).toBeInTheDocument();\n    });\n  });\n\n  describe('Color and Contrast', () => {\n    it('should meet WCAG AA color contrast requirements', async () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      const { container } = renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // Run axe color contrast tests\n      const results = await axe(container, {\n        rules: {\n          'color-contrast': { enabled: true }\n        }\n      });\n\n      expect(results).toHaveNoViolations();\n    });\n\n    it('should not rely solely on color for information', () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // Important information should have additional indicators beyond color\n      // This would be verified through visual inspection and design review\n      expect(screen.getByRole('application')).toBeInTheDocument();\n    });\n  });\n\n  describe('Mobile Accessibility', () => {\n    it('should support touch accessibility features', () => {\n      // Mock mobile viewport\n      Object.defineProperty(window, 'innerWidth', {\n        value: 375,\n        configurable: true\n      });\n\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // Touch targets should be adequate size (44px minimum)\n      const buttons = screen.getAllByRole('button');\n      buttons.forEach(button => {\n        const rect = button.getBoundingClientRect();\n        // Note: In test environment, getBoundingClientRect returns 0\n        // In real implementation, would check for minimum touch target size\n        expect(button).toBeInTheDocument();\n      });\n    });\n\n    it('should support voice control and switch navigation', () => {\n      const testData = createTestData.complete();\n      const mockProps = createMockProps.unifiedTacticsBoard();\n\n      renderWithProviders(\n        <UnifiedTacticsBoard {...mockProps} />,\n        {\n          initialTacticsState: testData.tacticsState,\n          initialUIState: testData.uiState\n        }\n      );\n\n      // All interactive elements should be accessible via voice/switch\n      const interactiveElements = [\n        ...screen.getAllByRole('button'),\n        ...screen.getAllByRole('link'),\n        ...screen.getAllByRole('checkbox'),\n        ...screen.getAllByRole('combobox')\n      ];\n\n      interactiveElements.forEach(element => {\n        // Should have accessible name for voice control\n        expect(element).toHaveAccessibleName();\n        \n        // Should be keyboard accessible for switch navigation\n        expect(element).not.toHaveAttribute('tabindex', '-1');\n      });\n    });\n  });\n});"
/**
 * Professional Sports Data API Integration Service
 *
 * Provides comprehensive integration with professional soccer data APIs,
 * performance analytics, and industry-standard statistics for benchmarking
 */

import axios, { type AxiosInstance } from 'axios';
import { v4 as uuidv4 } from 'uuid';

export interface SportsDataProvider {
  id: string;
  name: string;
  type:
    | 'football_api'
    | 'sports_radar'
    | 'catapult'
    | 'stats_sports'
    | 'wearable_device'
    | 'custom';
  baseUrl: string;
  apiKey?: string;
  isActive: boolean;
  rateLimitPerMinute: number;
  currentUsage: number;
  lastReset: number;
  supportedFeatures: string[];
}

export interface ProfessionalPlayer {
  id: string;
  name: string;
  position: string;
  age: number;
  nationality: string;
  club: string;
  league: string;
  marketValue: number;
  stats: {
    appearances: number;
    goals: number;
    assists: number;
    passAccuracy: number;
    tacklesWon: number;
    aerialDuelsWon: number;
    rating: number;
  };
  physicalData?: {
    height: number;
    weight: number;
    topSpeed: number;
    distanceCovered: number;
    sprintsPerGame: number;
  };
}

export interface LeagueData {
  id: string;
  name: string;
  country: string;
  season: string;
  teams: {
    id: string;
    name: string;
    position: number;
    points: number;
    played: number;
    won: number;
    drawn: number;
    lost: number;
    goalsFor: number;
    goalsAgainst: number;
  }[];
}

export interface MatchData {
  id: string;
  homeTeam: string;
  awayTeam: string;
  date: string;
  score: {
    home: number;
    away: number;
  };
  events: {
    minute: number;
    type: 'goal' | 'yellow_card' | 'red_card' | 'substitution';
    player: string;
    team: 'home' | 'away';
  }[];
  statistics: {
    possession: { home: number; away: number };
    shots: { home: number; away: number };
    shotsOnTarget: { home: number; away: number };
    passes: { home: number; away: number };
    passAccuracy: { home: number; away: number };
    fouls: { home: number; away: number };
  };
}

export interface PerformanceMetrics {
  playerId: string;
  date: string;
  metrics: {
    distanceCovered: number;
    maxSpeed: number;
    averageSpeed: number;
    sprintCount: number;
    heartRateAvg: number;
    heartRateMax: number;
    accelerations: number;
    decelerations: number;
    highIntensityActions: number;
    playerLoad: number;
  };
  zones: {
    walking: number;
    jogging: number;
    running: number;
    sprinting: number;
  };
}

export interface MarketData {
  playerId: string;
  currentValue: number;
  valueHistory: { date: string; value: number }[];
  transferHistory: {
    date: string;
    fromClub: string;
    toClub: string;
    fee: number;
    type: 'transfer' | 'loan';
  }[];
  contractExpiry: string;
  estimatedWage: number;
}

export interface BenchmarkData {
  position: string;
  league: string;
  ageGroup: string;
  benchmarks: {
    goals: { avg: number; top10: number; top5: number };
    assists: { avg: number; top10: number; top5: number };
    passAccuracy: { avg: number; top10: number; top5: number };
    tacklesWon: { avg: number; top10: number; top5: number };
    rating: { avg: number; top10: number; top5: number };
  };
}

class SportsDataApiService {
  private providers: Map<string, SportsDataProvider> = new Map();
  private apiClients: Map<string, AxiosInstance> = new Map();
  private dataCache: Map<string, { data: unknown; expiry: number }> = new Map();
  private performanceBuffer: Map<string, PerformanceMetrics[]> = new Map();

  // Event callbacks
  private onDataUpdateCallback?: (type: string, data: unknown) => void;
  private onPerformanceDataCallback?: (metrics: PerformanceMetrics) => void;
  private onBenchmarkUpdateCallback?: (benchmark: BenchmarkData) => void;

  constructor() {
    this.initializeProviders();
    this.setupApiClients();
    this.setupPerformanceStreaming();
  }

  /**
   * Initialize sports data API service
   */
  async initialize(): Promise<void> {
    await this.loadApiCredentials();
    await this.testConnections();
    // // // // console.log('‚öΩ Sports data API service initialized');
  }

  /**
   * Configure sports data provider
   */
  async configureProvider(config: Partial<SportsDataProvider>): Promise<void> {
    const provider: SportsDataProvider = {
      id: config.id || uuidv4(),
      name: config.name || '',
      type: config.type || 'football_api',
      baseUrl: config.baseUrl || '',
      apiKey: config.apiKey ?? undefined,
      isActive: config.isActive || false,
      rateLimitPerMinute: config.rateLimitPerMinute || 100,
      currentUsage: 0,
      lastReset: Date.now(),
      supportedFeatures: config.supportedFeatures || [],
    };

    this.providers.set(provider.id, provider);

    if (provider.isActive && provider.apiKey) {
      this.setupApiClient(provider);
    }

    // // // // console.log(`üìä Sports data provider configured: ${provider.name}`);
  }

  /**
   * Search professional players for benchmarking
   */
  async searchProfessionalPlayers(criteria: {
    position?: string;
    league?: string;
    ageMin?: number;
    ageMax?: number;
    nationality?: string;
    marketValueMin?: number;
    marketValueMax?: number;
  }): Promise<ProfessionalPlayer[]> {
    const cacheKey = `players_${JSON.stringify(criteria)}`;
    const cached = this.getFromCache(cacheKey);

    if (cached) {
      return cached as ProfessionalPlayer[];
    }

    try {
      const footballApiProvider = this.getProvider('football_api');
      if (!footballApiProvider?.isActive) {
        throw new Error('Football API provider not active');
      }

      const client = this.apiClients.get(footballApiProvider.id);
      if (!client) {
        throw new Error('API client not configured');
      }

      const response = await client.get('/players/search', {
        params: criteria,
      });

      const players: ProfessionalPlayer[] = response.data.players.map((player: any) => ({
        id: player.id,
        name: player.name,
        position: player.position,
        age: player.age,
        nationality: player.nationality,
        club: player.team?.name,
        league: player.league?.name,
        marketValue: player.market_value,
        stats: {
          appearances: player.statistics?.appearances || 0,
          goals: player.statistics?.goals || 0,
          assists: player.statistics?.assists || 0,
          passAccuracy: player.statistics?.pass_accuracy || 0,
          tacklesWon: player.statistics?.tackles_won || 0,
          aerialDuelsWon: player.statistics?.aerial_duels_won || 0,
          rating: player.statistics?.rating || 0,
        },
      }));

      this.setCache(cacheKey, players, 30 * 60 * 1000); // 30 minutes
      return players;
    } catch (_error) {
      console.error('‚ùå Failed to search professional players:', _error);
      return [] as ProfessionalPlayer[];
    }
  }

  /**
   * Get league standings and statistics
   */
  async getLeagueData(leagueId: string, season: string = '2024'): Promise<LeagueData | null> {
    const cacheKey = `league_${leagueId}_${season}`;
    const cached = this.getFromCache(cacheKey);

    if (cached) {
      return cached as LeagueData;
    }

    try {
      const provider = this.getProvider('football_api');
      if (!provider?.isActive) {
        return null;
      }

      const client = this.apiClients.get(provider.id);
      if (!client) {
        return null;
      }

      const response = await client.get(`/leagues/${leagueId}/standings`, {
        params: { season },
      });

      const leagueData: LeagueData = {
        id: leagueId,
        name: response.data.league.name,
        country: response.data.league.country,
        season,
        teams: response.data.standings[0].map((team: any) => ({
          id: team.team.id,
          name: team.team.name,
          position: team.rank,
          points: team.points,
          played: team.all.played,
          won: team.all.win,
          drawn: team.all.draw,
          lost: team.all.lose,
          goalsFor: team.all.goals.for,
          goalsAgainst: team.all.goals.against,
        })),
      };

      this.setCache(cacheKey, leagueData, 60 * 60 * 1000); // 1 hour
      return leagueData;
    } catch (_error) {
      console.error('‚ùå Failed to get league data:', _error);
      return {} as LeagueData;
    }
  }

  /**
   * Get detailed match data for analysis
   */
  async getMatchData(matchId: string): Promise<MatchData | null> {
    const cacheKey = `match_${matchId}`;
    const cached = this.getFromCache(cacheKey);

    if (cached) {
      return cached as MatchData;
    }

    try {
      const provider = this.getProvider('football_api');
      if (!provider?.isActive) {
        return null;
      }

      const client = this.apiClients.get(provider.id);
      if (!client) {
        return null;
      }

      const response = await client.get(`/matches/${matchId}`, {
        params: { include: 'events,statistics' },
      });

      const match = response.data;
      const matchData: MatchData = {
        id: matchId,
        homeTeam: match.teams.home.name,
        awayTeam: match.teams.away.name,
        date: match.fixture.date,
        score: {
          home: match.goals.home,
          away: match.goals.away,
        },
        events:
          match.events?.map((event: any) => ({
            minute: event.time.elapsed,
            type: event.type.toLowerCase(),
            player: event.player?.name || '',
            team: event.team.id === match.teams.home.id ? 'home' : 'away',
          })) || [],
        statistics: {
          possession: {
            home: this.extractStatistic(match.statistics, 'Ball Possession', 'home'),
            away: this.extractStatistic(match.statistics, 'Ball Possession', 'away'),
          },
          shots: {
            home: this.extractStatistic(match.statistics, 'Total Shots', 'home'),
            away: this.extractStatistic(match.statistics, 'Total Shots', 'away'),
          },
          shotsOnTarget: {
            home: this.extractStatistic(match.statistics, 'Shots on Goal', 'home'),
            away: this.extractStatistic(match.statistics, 'Shots on Goal', 'away'),
          },
          passes: {
            home: this.extractStatistic(match.statistics, 'Total passes', 'home'),
            away: this.extractStatistic(match.statistics, 'Total passes', 'away'),
          },
          passAccuracy: {
            home: this.extractStatistic(match.statistics, 'Passes %', 'home'),
            away: this.extractStatistic(match.statistics, 'Passes %', 'away'),
          },
          fouls: {
            home: this.extractStatistic(match.statistics, 'Fouls', 'home'),
            away: this.extractStatistic(match.statistics, 'Fouls', 'away'),
          },
        },
      };

      this.setCache(cacheKey, matchData, 24 * 60 * 60 * 1000); // 24 hours
      return matchData;
    } catch (_error) {
      console.error('‚ùå Failed to get match data:', _error);
      return null;
    }
  }

  /**
   * Connect wearable device for performance tracking
   */
  async connectWearableDevice(
    deviceType: 'catapult' | 'stats_sports' | 'polar' | 'garmin',
    deviceId: string,
    playerId: string,
  ): Promise<void> {
    try {
      const provider = this.getProvider(deviceType);
      if (!provider) {
        throw new Error(`Provider not found: ${deviceType}`);
      }

      // Device-specific connection logic
      switch (deviceType) {
        case 'catapult':
          await this.connectCatapultDevice(provider, deviceId, playerId);
          break;

        case 'stats_sports':
          await this.connectStatsSportsDevice(provider, deviceId, playerId);
          break;

        case 'polar':
          await this.connectPolarDevice(provider, deviceId, playerId);
          break;

        case 'garmin':
          await this.connectGarminDevice(provider, deviceId, playerId);
          break;
      }

      // // // // console.log(`üì± Connected ${deviceType} device for player ${playerId}`);
    } catch (_error) {
      console.error(`‚ùå Failed to connect ${deviceType} device:`, _error);
      throw _error;
    }
  }

  /**
   * Get real-time performance data from wearable devices
   */
  async getPerformanceData(
    playerId: string,
    startDate: string,
    endDate: string,
  ): Promise<PerformanceMetrics[]> {
    const cacheKey = `performance_${playerId}_${startDate}_${endDate}`;
    const cached = this.getFromCache(cacheKey);

    if (cached) {
      return cached as PerformanceMetrics[];
    }

    try {
      const performanceData: PerformanceMetrics[] = [];

      // Collect from all connected performance providers
      for (const provider of this.providers.values()) {
        if (!provider.isActive || !provider.supportedFeatures.includes('performance_tracking')) {
          continue;
        }

        const data = await this.fetchPerformanceFromProvider(
          provider,
          playerId,
          startDate,
          endDate,
        );
        performanceData.push(...data);
      }

      // Sort by date
      performanceData.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

      this.setCache(cacheKey, performanceData, 10 * 60 * 1000); // 10 minutes
      return performanceData;
    } catch (_error) {
      console.error('‚ùå Failed to get performance data:', _error);
      return [] as PerformanceMetrics[];
    }
  }

  /**
   * Get market value data and transfer information
   */
  async getPlayerMarketData(playerId: string): Promise<MarketData | null> {
    const cacheKey = `market_${playerId}`;
    const cached = this.getFromCache(cacheKey);

    if (cached) {
      return cached as MarketData;
    }

    try {
      const provider = this.getProvider('football_api');
      if (!provider?.isActive) {
        return null;
      }

      const client = this.apiClients.get(provider.id);
      if (!client) {
        return null;
      }

      const response = await client.get(`/players/${playerId}/transfers`);
      const transferData = response.data;

      const marketData: MarketData = {
        playerId,
        currentValue: transferData.market_value || 0,
        valueHistory:
          transferData.value_history?.map((entry: any) => ({
            date: entry.date,
            value: entry.value,
          })) || [],
        transferHistory:
          transferData.transfers?.map((transfer: any) => ({
            date: transfer.date,
            fromClub: transfer.from?.name || '',
            toClub: transfer.to?.name || '',
            fee: transfer.fee || 0,
            type: transfer.type || 'transfer',
          })) || [],
        contractExpiry: transferData.contract_expiry || '',
        estimatedWage: transferData.estimated_wage || 0,
      };

      this.setCache(cacheKey, marketData, 24 * 60 * 60 * 1000); // 24 hours
      return marketData;
    } catch (_error) {
      console.error('‚ùå Failed to get market data:', _error);
      return null;
    }
  }

  /**
   * Get position benchmarks for player comparison
   */
  async getPositionBenchmarks(
    position: string,
    league: string = 'all',
    ageGroup: string = 'all',
  ): Promise<BenchmarkData | null> {
    const cacheKey = `benchmark_${position}_${league}_${ageGroup}`;
    const cached = this.getFromCache(cacheKey);

    if (cached) {
      return cached as BenchmarkData;
    }

    try {
      // This would typically aggregate data from multiple sources
      const benchmarkData = await this.calculateBenchmarks(position, league, ageGroup);

      this.setCache(cacheKey, benchmarkData, 60 * 60 * 1000); // 1 hour

      if (this.onBenchmarkUpdateCallback) {
        this.onBenchmarkUpdateCallback(benchmarkData);
      }

      return benchmarkData;
    } catch (_error) {
      console.error('‚ùå Failed to get position benchmarks:', _error);
      return {} as BenchmarkData;
    }
  }

  /**
   * Stream live match data
   */
  async startLiveMatchStream(matchId: string): Promise<void> {
    try {
      const provider = this.getProvider('sports_radar');
      if (!provider?.isActive) {
        throw new Error('Live streaming provider not available');
      }

      // WebSocket connection for live data
      const wsUrl = `${provider.baseUrl.replace('http', 'ws')}/matches/${matchId}/live`;
      const ws = typeof WebSocket !== 'undefined' ? new WebSocket(wsUrl) : null;

      if (ws) {
        ws.onmessage = event => {
          const data = JSON.parse(event.data);

          if (this.onDataUpdateCallback) {
            this.onDataUpdateCallback('live_match', data);
          }
        };

        ws.onerror = error => {
          console.error('‚ùå Live match stream error:', error);
        };

        // // // // console.log(`üì° Started live match stream for match ${matchId}`);
      }
    } catch (_error) {
      console.error('‚ùå Failed to start live match stream:', _error);
    }
  }

  /**
   * Generate injury prevention insights
   */
  async getInjuryPreventionInsights(playerId: string): Promise<{
    riskScore: number;
    factors: string[];
    recommendations: string[];
  }> {
    try {
      const performanceData = await this.getPerformanceData(
        playerId,
        new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(), // Last 30 days
        new Date().toISOString(),
      );

      // Analyze performance data for injury risk factors
      const riskFactors = this.analyzeInjuryRisk(performanceData);

      return {
        riskScore: riskFactors.score,
        factors: riskFactors.factors,
        recommendations: riskFactors.recommendations,
      };
    } catch (_error) {
      console.error('‚ùå Failed to generate injury prevention insights:', _error);
      return { riskScore: 0, factors: [], recommendations: [] };
    }
  }

  // Event listener setters
  onDataUpdate(callback: (type: string, data: unknown) => void): void {
    this.onDataUpdateCallback = callback;
  }

  onPerformanceData(callback: (metrics: PerformanceMetrics) => void): void {
    this.onPerformanceDataCallback = callback;
  }

  onBenchmarkUpdate(callback: (benchmark: BenchmarkData) => void): void {
    this.onBenchmarkUpdateCallback = callback;
  }

  // Private methods

  private initializeProviders(): void {
    const defaultProviders = [
      {
        id: 'football_api',
        name: 'Football API',
        type: 'football_api' as const,
        baseUrl: 'https://api-football-v1.p.rapidapi.com/v3',
        supportedFeatures: ['player_search', 'league_data', 'match_data', 'transfer_data'],
      },
      {
        id: 'sports_radar',
        name: 'SportRadar',
        type: 'sports_radar' as const,
        baseUrl: 'https://api.sportradar.com/soccer',
        supportedFeatures: ['live_data', 'detailed_statistics', 'historical_data'],
      },
      {
        id: 'catapult',
        name: 'Catapult Sports',
        type: 'catapult' as const,
        baseUrl: 'https://api.catapultsports.com',
        supportedFeatures: ['performance_tracking', 'gps_data', 'injury_prevention'],
      },
      {
        id: 'stats_sports',
        name: 'STATSports',
        type: 'stats_sports' as const,
        baseUrl: 'https://api.statsports.com',
        supportedFeatures: ['performance_tracking', 'heart_rate', 'load_monitoring'],
      },
    ];

    defaultProviders.forEach(provider => {
      this.providers.set(provider.id, {
        ...provider,
        isActive: false,
        rateLimitPerMinute: 100,
        currentUsage: 0,
        lastReset: Date.now(),
      });
    });
  }

  private setupApiClients(): void {
    for (const provider of this.providers.values()) {
      if (provider.isActive && provider.apiKey) {
        this.setupApiClient(provider);
      }
    }
  }

  private setupApiClient(provider: SportsDataProvider): void {
    const client = axios.create({
      baseURL: provider.baseUrl,
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
        ...(provider.apiKey && { 'X-API-Key': provider.apiKey }),
      },
    });

    // Add rate limiting
    client.interceptors.request.use(async config => {
      if (!this.checkRateLimit(provider)) {
        throw new Error(`Rate limit exceeded for ${provider.name}`);
      }

      provider.currentUsage++;
      return config;
    });

    // Add response interceptors for error handling
    client.interceptors.response.use(
      response => response,
      error => {
        console.error(`API Error from ${provider.name}:`, error.message);
        return Promise.reject(error);
      },
    );

    this.apiClients.set(provider.id, client);
  }

  private setupPerformanceStreaming(): void {
    // Setup real-time performance data streaming
    setInterval(() => {
      this.processPerformanceBuffer();
    }, 5000); // Process every 5 seconds

    // Reset rate limits every minute
    setInterval(() => {
      this.resetRateLimits();
    }, 60000);
  }

  private getProvider(type: string): SportsDataProvider | undefined {
    return Array.from(this.providers.values()).find(p => p.type === type || p.id === type);
  }

  private checkRateLimit(provider: SportsDataProvider): boolean {
    const now = Date.now();
    const minuteAgo = now - 60000;

    if (provider.lastReset < minuteAgo) {
      provider.currentUsage = 0;
      provider.lastReset = now;
    }

    return provider.currentUsage < provider.rateLimitPerMinute;
  }

  private resetRateLimits(): void {
    const now = Date.now();

    for (const provider of this.providers.values()) {
      provider.currentUsage = 0;
      provider.lastReset = now;
    }
  }

  private getFromCache(key: string): unknown {
    const cached = this.dataCache.get(key);
    if (cached && cached.expiry > Date.now()) {
      return cached.data;
    }

    this.dataCache.delete(key);
    return null;
  }

  private setCache(key: string, data: unknown, ttl: number): void {
    this.dataCache.set(key, {
      data,
      expiry: Date.now() + ttl,
    });

    // Clean old cache entries
    if (this.dataCache.size > 1000) {
      const now = Date.now();
      for (const [cacheKey, cache] of this.dataCache.entries()) {
        if (cache.expiry <= now) {
          this.dataCache.delete(cacheKey);
        }
      }
    }
  }

  private extractStatistic(statistics: any[], type: string, team: 'home' | 'away'): number {
    const stat = statistics?.find((s: any) => s.type === type);
    if (!stat) {
      return 0;
    }

    const value = team === 'home' ? stat.home : stat.away;
    return parseInt(value) || 0;
  }

  private async connectCatapultDevice(
    provider: SportsDataProvider,
    deviceId: string,
    playerId: string,
  ): Promise<void> {
    // // // // console.log(`üîó Connecting Catapult device ${deviceId} for player ${playerId}`);
    // Catapult-specific connection logic
  }

  private async connectStatsSportsDevice(
    provider: SportsDataProvider,
    deviceId: string,
    playerId: string,
  ): Promise<void> {
    // // // // console.log(`üîó Connecting STATSports device ${deviceId} for player ${playerId}`);
    // STATSports-specific connection logic
  }

  private async connectPolarDevice(
    provider: SportsDataProvider,
    deviceId: string,
    playerId: string,
  ): Promise<void> {
    // // // // console.log(`üîó Connecting Polar device ${deviceId} for player ${playerId}`);
    // Polar-specific connection logic
  }

  private async connectGarminDevice(
    provider: SportsDataProvider,
    deviceId: string,
    playerId: string,
  ): Promise<void> {
    // // // // console.log(`üîó Connecting Garmin device ${deviceId} for player ${playerId}`);
    // Garmin-specific connection logic
  }

  private async fetchPerformanceFromProvider(
    _provider: SportsDataProvider,
    _playerId: string,
    _startDate: string,
    _endDate: string,
  ): Promise<PerformanceMetrics[]> {
    // Provider-specific performance data fetching
    return [];
  }

  private async calculateBenchmarks(
    position: string,
    league: string,
    ageGroup: string,
  ): Promise<BenchmarkData> {
    // Calculate position benchmarks from aggregated data
    return {
      position,
      league,
      ageGroup,
      benchmarks: {
        goals: { avg: 0.2, top10: 0.8, top5: 1.2 },
        assists: { avg: 0.15, top10: 0.6, top5: 0.9 },
        passAccuracy: { avg: 82, top10: 91, top5: 94 },
        tacklesWon: { avg: 1.8, top10: 3.2, top5: 4.1 },
        rating: { avg: 6.8, top10: 7.8, top5: 8.2 },
      },
    };
  }

  private processPerformanceBuffer(): void {
    // Process buffered performance data
    for (const [playerId, metrics] of this.performanceBuffer.entries()) {
      if (metrics.length > 0) {
        const latestMetric = metrics[metrics.length - 1];

        if (this.onPerformanceDataCallback) {
          this.onPerformanceDataCallback(latestMetric);
        }

        // Clear processed metrics
        this.performanceBuffer.set(playerId, []);
      }
    }
  }

  private analyzeInjuryRisk(performanceData: PerformanceMetrics[]): {
    score: number;
    factors: string[];
    recommendations: string[];
  } {
    // Analyze performance data for injury risk indicators
    const riskFactors: string[] = [];
    const recommendations: string[] = [];
    let riskScore = 0;

    if (performanceData.length === 0) {
      return { score: 0, factors: [], recommendations: [] };
    }

    // Analyze trends
    const recent = performanceData.slice(-7); // Last 7 sessions
    const avgLoad = recent.reduce((sum, m) => sum + m.metrics.playerLoad, 0) / recent.length;

    // High load detection
    if (avgLoad > 500) {
      riskScore += 20;
      riskFactors.push('High training load detected');
      recommendations.push('Consider reducing training intensity');
    }

    // Rapid load increases
    if (recent.length >= 2) {
      const loadIncrease =
        recent[recent.length - 1].metrics.playerLoad - recent[0].metrics.playerLoad;
      if (loadIncrease > 100) {
        riskScore += 15;
        riskFactors.push('Rapid load increase');
        recommendations.push('Gradual load progression recommended');
      }
    }

    // High heart rate patterns
    const avgMaxHR = recent.reduce((sum, m) => sum + m.metrics.heartRateMax, 0) / recent.length;
    if (avgMaxHR > 190) {
      riskScore += 10;
      riskFactors.push('Elevated heart rate patterns');
      recommendations.push('Monitor cardiovascular stress');
    }

    return {
      score: Math.min(riskScore, 100),
      factors: riskFactors,
      recommendations,
    };
  }

  private async loadApiCredentials(): Promise<void> {
    // Load API credentials from secure storage
    // // // // console.log('üîê Loading API credentials');
  }

  private async testConnections(): Promise<void> {
    for (const provider of this.providers.values()) {
      if (provider.isActive) {
        try {
          const client = this.apiClients.get(provider.id);
          if (client) {
            await client.get('/health', { timeout: 5000 });
            // // // // console.log(`‚úÖ ${provider.name} connection successful`);
          }
        } catch (_error) {
          console.error(`‚ùå ${provider.name} connection failed:`, (_error as Error).message);
          provider.isActive = false;
        }
      }
    }
  }
}

// Singleton instance
export const sportsDataApiService = new SportsDataApiService();

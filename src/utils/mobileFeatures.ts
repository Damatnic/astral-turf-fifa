/**
 * Mobile-Specific Feature Integration
 * Comprehensive mobile features: haptics, orientation, device sensors, and native integrations
 */

import { useCallback, useEffect, useRef, useState } from 'react';\nimport { useMobileCapabilities } from './mobileOptimizations';\n\n// Haptic feedback patterns\nexport const HapticPatterns = {\n  LIGHT_TAP: [10],\n  MEDIUM_TAP: [25],\n  HEAVY_TAP: [50],\n  DOUBLE_TAP: [15, 10, 15],\n  SUCCESS: [25, 10, 25],\n  ERROR: [50, 25, 50, 25, 50],\n  WARNING: [30, 20, 30],\n  SELECTION: [5],\n  DRAG_START: [20],\n  DRAG_END: [15],\n  NOTIFICATION: [100, 50, 100],\n  GAME_ACTION: [30, 10, 20],\n  FORMATION_CHANGE: [40, 15, 25, 15, 40],\n} as const;\n\n// Device orientation types\nexport interface DeviceOrientation {\n  alpha: number | null; // Z-axis rotation (0-360°)\n  beta: number | null;  // X-axis rotation (-180° to 180°)\n  gamma: number | null; // Y-axis rotation (-90° to 90°)\n  absolute: boolean;\n}\n\n// Device motion data\nexport interface DeviceMotion {\n  acceleration: {\n    x: number | null;\n    y: number | null;\n    z: number | null;\n  };\n  accelerationIncludingGravity: {\n    x: number | null;\n    y: number | null;\n    z: number | null;\n  };\n  rotationRate: {\n    alpha: number | null;\n    beta: number | null;\n    gamma: number | null;\n  };\n  interval: number;\n}\n\n// Screen orientation types\nexport type ScreenOrientationType = \n  | 'portrait-primary'\n  | 'portrait-secondary'\n  | 'landscape-primary'\n  | 'landscape-secondary';\n\n/**\n * Enhanced Haptic Feedback Manager\n */\nexport class HapticFeedbackManager {\n  private static instance: HapticFeedbackManager;\n  private isSupported: boolean;\n  private intensity: 'light' | 'medium' | 'heavy';\n  private isEnabled: boolean;\n  \n  static getInstance(): HapticFeedbackManager {\n    if (!HapticFeedbackManager.instance) {\n      HapticFeedbackManager.instance = new HapticFeedbackManager();\n    }\n    return HapticFeedbackManager.instance;\n  }\n  \n  private constructor() {\n    this.isSupported = 'vibrate' in navigator;\n    this.intensity = 'medium';\n    this.isEnabled = true;\n    \n    // Check for iOS haptic feedback APIs\n    if ('DeviceMotionEvent' in window && typeof (DeviceMotionEvent as any).requestPermission === 'function') {\n      this.isSupported = true;\n    }\n  }\n  \n  /**\n   * Trigger haptic feedback with pattern\n   */\n  vibrate(pattern: number | number[]): boolean {\n    if (!this.isSupported || !this.isEnabled) {\n      return false;\n    }\n    \n    try {\n      // Adjust pattern based on intensity\n      let adjustedPattern: number | number[];\n      \n      if (Array.isArray(pattern)) {\n        const multiplier = this.getIntensityMultiplier();\n        adjustedPattern = pattern.map(duration => Math.round(duration * multiplier));\n      } else {\n        adjustedPattern = Math.round(pattern * this.getIntensityMultiplier());\n      }\n      \n      navigator.vibrate(adjustedPattern);\n      return true;\n    } catch (error) {\n      console.warn('Haptic feedback failed:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Trigger predefined haptic pattern\n   */\n  triggerPattern(patternName: keyof typeof HapticPatterns): boolean {\n    const pattern = HapticPatterns[patternName];\n    return this.vibrate(pattern);\n  }\n  \n  /**\n   * Trigger contextual feedback for tactical board actions\n   */\n  tacticalFeedback(action: 'select' | 'move' | 'formation_change' | 'success' | 'error'): boolean {\n    switch (action) {\n      case 'select':\n        return this.triggerPattern('SELECTION');\n      case 'move':\n        return this.triggerPattern('LIGHT_TAP');\n      case 'formation_change':\n        return this.triggerPattern('FORMATION_CHANGE');\n      case 'success':\n        return this.triggerPattern('SUCCESS');\n      case 'error':\n        return this.triggerPattern('ERROR');\n      default:\n        return this.triggerPattern('LIGHT_TAP');\n    }\n  }\n  \n  /**\n   * Adaptive feedback based on device and context\n   */\n  adaptiveFeedback(context: {\n    action: string;\n    importance: 'low' | 'medium' | 'high';\n    batteryLevel?: number;\n    thermalState?: string;\n  }): boolean {\n    // Reduce haptic feedback on low battery or thermal throttling\n    if (context.batteryLevel && context.batteryLevel < 0.2) {\n      return false;\n    }\n    \n    if (context.thermalState === 'critical' || context.thermalState === 'serious') {\n      return false;\n    }\n    \n    let pattern: number[];\n    \n    switch (context.importance) {\n      case 'low':\n        pattern = HapticPatterns.LIGHT_TAP;\n        break;\n      case 'medium':\n        pattern = HapticPatterns.MEDIUM_TAP;\n        break;\n      case 'high':\n        pattern = HapticPatterns.HEAVY_TAP;\n        break;\n      default:\n        pattern = HapticPatterns.LIGHT_TAP;\n    }\n    \n    return this.vibrate(pattern);\n  }\n  \n  private getIntensityMultiplier(): number {\n    switch (this.intensity) {\n      case 'light': return 0.7;\n      case 'medium': return 1.0;\n      case 'heavy': return 1.3;\n      default: return 1.0;\n    }\n  }\n  \n  setIntensity(intensity: 'light' | 'medium' | 'heavy'): void {\n    this.intensity = intensity;\n  }\n  \n  setEnabled(enabled: boolean): void {\n    this.isEnabled = enabled;\n  }\n  \n  isHapticSupported(): boolean {\n    return this.isSupported;\n  }\n}\n\n/**\n * Device Orientation Manager\n */\nexport class DeviceOrientationManager {\n  private static instance: DeviceOrientationManager;\n  private isSupported: boolean;\n  private isPermissionGranted: boolean = false;\n  private orientation: DeviceOrientation = {\n    alpha: null,\n    beta: null,\n    gamma: null,\n    absolute: false,\n  };\n  private motion: DeviceMotion = {\n    acceleration: { x: null, y: null, z: null },\n    accelerationIncludingGravity: { x: null, y: null, z: null },\n    rotationRate: { alpha: null, beta: null, gamma: null },\n    interval: 0,\n  };\n  private listeners: Set<(orientation: DeviceOrientation) => void> = new Set();\n  private motionListeners: Set<(motion: DeviceMotion) => void> = new Set();\n  \n  static getInstance(): DeviceOrientationManager {\n    if (!DeviceOrientationManager.instance) {\n      DeviceOrientationManager.instance = new DeviceOrientationManager();\n    }\n    return DeviceOrientationManager.instance;\n  }\n  \n  private constructor() {\n    this.isSupported = 'DeviceOrientationEvent' in window && 'DeviceMotionEvent' in window;\n    \n    if (this.isSupported) {\n      this.setupEventListeners();\n    }\n  }\n  \n  /**\n   * Request permission for device orientation (iOS 13+)\n   */\n  async requestPermission(): Promise<boolean> {\n    if (!this.isSupported) {\n      return false;\n    }\n    \n    try {\n      // iOS 13+ requires permission\n      if (typeof (DeviceOrientationEvent as any).requestPermission === 'function') {\n        const orientationPermission = await (DeviceOrientationEvent as any).requestPermission();\n        const motionPermission = await (DeviceMotionEvent as any).requestPermission();\n        \n        this.isPermissionGranted = orientationPermission === 'granted' && motionPermission === 'granted';\n      } else {\n        // Other browsers\n        this.isPermissionGranted = true;\n      }\n      \n      return this.isPermissionGranted;\n    } catch (error) {\n      console.warn('Device orientation permission request failed:', error);\n      return false;\n    }\n  }\n  \n  private setupEventListeners(): void {\n    const handleOrientationChange = (event: DeviceOrientationEvent) => {\n      this.orientation = {\n        alpha: event.alpha,\n        beta: event.beta,\n        gamma: event.gamma,\n        absolute: event.absolute,\n      };\n      \n      this.listeners.forEach(listener => listener(this.orientation));\n    };\n    \n    const handleMotionChange = (event: DeviceMotionEvent) => {\n      this.motion = {\n        acceleration: {\n          x: event.acceleration?.x || null,\n          y: event.acceleration?.y || null,\n          z: event.acceleration?.z || null,\n        },\n        accelerationIncludingGravity: {\n          x: event.accelerationIncludingGravity?.x || null,\n          y: event.accelerationIncludingGravity?.y || null,\n          z: event.accelerationIncludingGravity?.z || null,\n        },\n        rotationRate: {\n          alpha: event.rotationRate?.alpha || null,\n          beta: event.rotationRate?.beta || null,\n          gamma: event.rotationRate?.gamma || null,\n        },\n        interval: event.interval,\n      };\n      \n      this.motionListeners.forEach(listener => listener(this.motion));\n    };\n    \n    window.addEventListener('deviceorientation', handleOrientationChange, { passive: true });\n    window.addEventListener('devicemotion', handleMotionChange, { passive: true });\n  }\n  \n  /**\n   * Subscribe to orientation changes\n   */\n  onOrientationChange(callback: (orientation: DeviceOrientation) => void): () => void {\n    this.listeners.add(callback);\n    \n    // Send current orientation immediately\n    callback(this.orientation);\n    \n    return () => {\n      this.listeners.delete(callback);\n    };\n  }\n  \n  /**\n   * Subscribe to motion changes\n   */\n  onMotionChange(callback: (motion: DeviceMotion) => void): () => void {\n    this.motionListeners.add(callback);\n    \n    // Send current motion immediately\n    callback(this.motion);\n    \n    return () => {\n      this.motionListeners.delete(callback);\n    };\n  }\n  \n  /**\n   * Get current orientation\n   */\n  getCurrentOrientation(): DeviceOrientation {\n    return { ...this.orientation };\n  }\n  \n  /**\n   * Get current motion data\n   */\n  getCurrentMotion(): DeviceMotion {\n    return { ...this.motion };\n  }\n  \n  /**\n   * Check if device is in landscape mode\n   */\n  isLandscape(): boolean {\n    return window.innerWidth > window.innerHeight;\n  }\n  \n  /**\n   * Get device tilt for tactical field orientation\n   */\n  getFieldTilt(): { x: number; y: number } {\n    const beta = this.orientation.beta || 0;\n    const gamma = this.orientation.gamma || 0;\n    \n    // Normalize to -1 to 1 range\n    const x = Math.max(-1, Math.min(1, gamma / 45));\n    const y = Math.max(-1, Math.min(1, (beta - 90) / 45));\n    \n    return { x, y };\n  }\n  \n  isSupported(): boolean {\n    return this.isSupported && this.isPermissionGranted;\n  }\n}\n\n/**\n * Screen Orientation Manager\n */\nexport class ScreenOrientationManager {\n  private static instance: ScreenOrientationManager;\n  private listeners: Set<(orientation: ScreenOrientationType) => void> = new Set();\n  \n  static getInstance(): ScreenOrientationManager {\n    if (!ScreenOrientationManager.instance) {\n      ScreenOrientationManager.instance = new ScreenOrientationManager();\n    }\n    return ScreenOrientationManager.instance;\n  }\n  \n  private constructor() {\n    this.setupEventListeners();\n  }\n  \n  private setupEventListeners(): void {\n    const handleOrientationChange = () => {\n      const orientation = this.getCurrentOrientation();\n      this.listeners.forEach(listener => listener(orientation));\n    };\n    \n    window.addEventListener('orientationchange', handleOrientationChange);\n    window.addEventListener('resize', handleOrientationChange);\n  }\n  \n  /**\n   * Get current screen orientation\n   */\n  getCurrentOrientation(): ScreenOrientationType {\n    if ('screen' in window && 'orientation' in window.screen) {\n      return window.screen.orientation.type as ScreenOrientationType;\n    }\n    \n    // Fallback based on window dimensions\n    const isLandscape = window.innerWidth > window.innerHeight;\n    return isLandscape ? 'landscape-primary' : 'portrait-primary';\n  }\n  \n  /**\n   * Lock screen orientation\n   */\n  async lockOrientation(orientation: OrientationLockType): Promise<boolean> {\n    if ('screen' in window && 'orientation' in window.screen && 'lock' in window.screen.orientation) {\n      try {\n        await window.screen.orientation.lock(orientation);\n        return true;\n      } catch (error) {\n        console.warn('Screen orientation lock failed:', error);\n        return false;\n      }\n    }\n    \n    return false;\n  }\n  \n  /**\n   * Unlock screen orientation\n   */\n  unlockOrientation(): void {\n    if ('screen' in window && 'orientation' in window.screen && 'unlock' in window.screen.orientation) {\n      window.screen.orientation.unlock();\n    }\n  }\n  \n  /**\n   * Subscribe to orientation changes\n   */\n  onOrientationChange(callback: (orientation: ScreenOrientationType) => void): () => void {\n    this.listeners.add(callback);\n    \n    // Send current orientation immediately\n    callback(this.getCurrentOrientation());\n    \n    return () => {\n      this.listeners.delete(callback);\n    };\n  }\n  \n  /**\n   * Optimize orientation for tactical board\n   */\n  async optimizeForTacticalBoard(): Promise<boolean> {\n    // For tactical board, landscape is usually better\n    return await this.lockOrientation('landscape');\n  }\n}\n\n/**\n * React Hooks for Mobile Features\n */\n\n/**\n * Hook for haptic feedback\n */\nexport const useHapticFeedback = () => {\n  const hapticManager = useRef(HapticFeedbackManager.getInstance());\n  const capabilities = useMobileCapabilities();\n  \n  const triggerHaptic = useCallback((pattern: keyof typeof HapticPatterns | number | number[]) => {\n    if (!capabilities.hasHapticFeedback) {\n      return false;\n    }\n    \n    if (typeof pattern === 'string') {\n      return hapticManager.current.triggerPattern(pattern);\n    } else {\n      return hapticManager.current.vibrate(pattern);\n    }\n  }, [capabilities.hasHapticFeedback]);\n  \n  const tacticalFeedback = useCallback((action: 'select' | 'move' | 'formation_change' | 'success' | 'error') => {\n    return hapticManager.current.tacticalFeedback(action);\n  }, []);\n  \n  const adaptiveFeedback = useCallback((context: {\n    action: string;\n    importance: 'low' | 'medium' | 'high';\n    batteryLevel?: number;\n    thermalState?: string;\n  }) => {\n    return hapticManager.current.adaptiveFeedback(context);\n  }, []);\n  \n  return {\n    triggerHaptic,\n    tacticalFeedback,\n    adaptiveFeedback,\n    isSupported: capabilities.hasHapticFeedback,\n    setIntensity: hapticManager.current.setIntensity.bind(hapticManager.current),\n    setEnabled: hapticManager.current.setEnabled.bind(hapticManager.current),\n  };\n};\n\n/**\n * Hook for device orientation\n */\nexport const useDeviceOrientation = () => {\n  const [orientation, setOrientation] = useState<DeviceOrientation>({\n    alpha: null,\n    beta: null,\n    gamma: null,\n    absolute: false,\n  });\n  const [motion, setMotion] = useState<DeviceMotion>({\n    acceleration: { x: null, y: null, z: null },\n    accelerationIncludingGravity: { x: null, y: null, z: null },\n    rotationRate: { alpha: null, beta: null, gamma: null },\n    interval: 0,\n  });\n  const [isSupported, setIsSupported] = useState(false);\n  const orientationManager = useRef(DeviceOrientationManager.getInstance());\n  \n  useEffect(() => {\n    const requestPermissionAndSetup = async () => {\n      const hasPermission = await orientationManager.current.requestPermission();\n      setIsSupported(hasPermission);\n      \n      if (hasPermission) {\n        const unsubscribeOrientation = orientationManager.current.onOrientationChange(setOrientation);\n        const unsubscribeMotion = orientationManager.current.onMotionChange(setMotion);\n        \n        return () => {\n          unsubscribeOrientation();\n          unsubscribeMotion();\n        };\n      }\n    };\n    \n    requestPermissionAndSetup();\n  }, []);\n  \n  const getFieldTilt = useCallback(() => {\n    return orientationManager.current.getFieldTilt();\n  }, []);\n  \n  return {\n    orientation,\n    motion,\n    isSupported,\n    getFieldTilt,\n    isLandscape: orientationManager.current.isLandscape.bind(orientationManager.current),\n  };\n};\n\n/**\n * Hook for screen orientation\n */\nexport const useScreenOrientation = () => {\n  const [orientation, setOrientation] = useState<ScreenOrientationType>('portrait-primary');\n  const orientationManager = useRef(ScreenOrientationManager.getInstance());\n  \n  useEffect(() => {\n    const unsubscribe = orientationManager.current.onOrientationChange(setOrientation);\n    return unsubscribe;\n  }, []);\n  \n  const lockOrientation = useCallback(async (lockType: OrientationLockType) => {\n    return await orientationManager.current.lockOrientation(lockType);\n  }, []);\n  \n  const unlockOrientation = useCallback(() => {\n    orientationManager.current.unlockOrientation();\n  }, []);\n  \n  const optimizeForTacticalBoard = useCallback(async () => {\n    return await orientationManager.current.optimizeForTacticalBoard();\n  }, []);\n  \n  return {\n    orientation,\n    lockOrientation,\n    unlockOrientation,\n    optimizeForTacticalBoard,\n    isLandscape: orientation.includes('landscape'),\n    isPortrait: orientation.includes('portrait'),\n  };\n};\n\n/**\n * Hook for Wake Lock API (keep screen on)\n */\nexport const useWakeLock = () => {\n  const [isActive, setIsActive] = useState(false);\n  const [isSupported, setIsSupported] = useState(false);\n  const wakeLockRef = useRef<WakeLockSentinel | null>(null);\n  \n  useEffect(() => {\n    setIsSupported('wakeLock' in navigator);\n  }, []);\n  \n  const requestWakeLock = useCallback(async () => {\n    if (!isSupported) {\n      return false;\n    }\n    \n    try {\n      wakeLockRef.current = await (navigator as any).wakeLock.request('screen');\n      setIsActive(true);\n      \n      wakeLockRef.current.addEventListener('release', () => {\n        setIsActive(false);\n      });\n      \n      return true;\n    } catch (error) {\n      console.warn('Wake lock request failed:', error);\n      return false;\n    }\n  }, [isSupported]);\n  \n  const releaseWakeLock = useCallback(async () => {\n    if (wakeLockRef.current) {\n      try {\n        await wakeLockRef.current.release();\n        wakeLockRef.current = null;\n        setIsActive(false);\n        return true;\n      } catch (error) {\n        console.warn('Wake lock release failed:', error);\n        return false;\n      }\n    }\n    return false;\n  }, []);\n  \n  // Auto-release on page visibility change\n  useEffect(() => {\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'hidden' && isActive) {\n        releaseWakeLock();\n      }\n    };\n    \n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    return () => {\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n      releaseWakeLock();\n    };\n  }, [isActive, releaseWakeLock]);\n  \n  return {\n    isActive,\n    isSupported,\n    requestWakeLock,\n    releaseWakeLock,\n  };\n};\n\n// Global instances\nexport const hapticManager = HapticFeedbackManager.getInstance();\nexport const orientationManager = DeviceOrientationManager.getInstance();\nexport const screenOrientationManager = ScreenOrientationManager.getInstance();\n\n// Utility functions\nexport const requestMobilePermissions = async (): Promise<{\n  orientation: boolean;\n  haptic: boolean;\n}> => {\n  const orientation = await orientationManager.requestPermission();\n  const haptic = hapticManager.isHapticSupported();\n  \n  return { orientation, haptic };\n};\n\nexport const optimizeMobileExperience = async (): Promise<void> => {\n  // Request all necessary permissions\n  await requestMobilePermissions();\n  \n  // Optimize screen orientation for tactical board\n  await screenOrientationManager.optimizeForTacticalBoard();\n  \n  // Set medium haptic intensity by default\n  hapticManager.setIntensity('medium');\n  \n  console.log('[Mobile] Experience optimized for tactical board');\n};\n\nexport default {\n  HapticFeedbackManager,\n  DeviceOrientationManager,\n  ScreenOrientationManager,\n  useHapticFeedback,\n  useDeviceOrientation,\n  useScreenOrientation,\n  useWakeLock,\n  HapticPatterns,\n  hapticManager,\n  orientationManager,\n  screenOrientationManager,\n  requestMobilePermissions,\n  optimizeMobileExperience,\n};
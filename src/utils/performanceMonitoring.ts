/**
 * Catalyst Performance Monitoring Suite
 * Comprehensive real-time performance tracking and optimization
 */

import { type Player, type Formation } from '../types';

// Performance thresholds and constants
export const PERFORMANCE_THRESHOLDS = {
  RENDER_TIME_WARNING: 16, // 60fps = 16.67ms per frame
  RENDER_TIME_CRITICAL: 33, // 30fps threshold
  MEMORY_WARNING: 50 * 1024 * 1024, // 50MB
  BUNDLE_SIZE_WARNING: 500 * 1024, // 500KB gzipped
  API_RESPONSE_WARNING: 1000, // 1 second
  INTERACTION_WARNING: 100, // 100ms for interactions
  LCP_TARGET: 2500, // Largest Contentful Paint
  FID_TARGET: 100, // First Input Delay
  CLS_TARGET: 0.1, // Cumulative Layout Shift
} as const;

// Performance metrics structure
interface PerformanceMetrics {
  // Rendering metrics
  renderTime: {
    current: number;
    average: number;
    max: number;
    slowRenders: number;
  };
  
  // Memory metrics
  memory: {
    usedJSHeapSize: number;
    totalJSHeapSize: number;
    jsHeapSizeLimit: number;
    trend: 'stable' | 'increasing' | 'decreasing';
  };
  
  // Network metrics
  network: {
    latency: number;
    bandwidth: number;
    connectionType: string;
    effectiveType: string;
  };
  
  // Core Web Vitals
  webVitals: {
    lcp: number | null;
    fid: number | null;
    cls: number | null;
    ttfb: number | null;
  };
  
  // Custom tactical metrics
  tactical: {
    playersRendered: number;
    formationComplexity: number;
    animationCount: number;
    interactionLatency: number;
  };
  
  // Battery status
  battery: {
    level: number;
    charging: boolean;
    chargingTime: number;
    dischargingTime: number;
  };
  
  // Device capabilities
  device: {
    hardwareConcurrency: number;
    deviceMemory: number;
    connection: string;
    platform: string;
    isMobile: boolean;
  };
}

// Advanced Performance Monitor
export class CatalystPerformanceMonitor {
  private static instance: CatalystPerformanceMonitor;
  private metrics: PerformanceMetrics;
  private observers: Map<string, PerformanceObserver> = new Map();
  private subscribers: Array<(metrics: PerformanceMetrics) => void> = [];
  private measurementHistory: Array<{ timestamp: number; metrics: Partial<PerformanceMetrics> }> = [];
  private isMonitoring = false;
  private updateInterval: NodeJS.Timeout | null = null;
  private memoryHistory: number[] = [];
  private renderTimes: number[] = [];
  
  static getInstance(): CatalystPerformanceMonitor {
    if (!CatalystPerformanceMonitor.instance) {
      CatalystPerformanceMonitor.instance = new CatalystPerformanceMonitor();
    }
    return CatalystPerformanceMonitor.instance;
  }
  
  constructor() {
    this.metrics = this.initializeMetrics();
    this.setupPerformanceObservers();
    this.detectDeviceCapabilities();
  }
  
  private initializeMetrics(): PerformanceMetrics {
    return {\n      renderTime: {\n        current: 0,\n        average: 0,\n        max: 0,\n        slowRenders: 0\n      },\n      memory: {\n        usedJSHeapSize: 0,\n        totalJSHeapSize: 0,\n        jsHeapSizeLimit: 0,\n        trend: 'stable'\n      },\n      network: {\n        latency: 0,\n        bandwidth: 0,\n        connectionType: 'unknown',\n        effectiveType: 'unknown'\n      },\n      webVitals: {\n        lcp: null,\n        fid: null,\n        cls: null,\n        ttfb: null\n      },\n      tactical: {\n        playersRendered: 0,\n        formationComplexity: 0,\n        animationCount: 0,\n        interactionLatency: 0\n      },\n      battery: {\n        level: 1,\n        charging: true,\n        chargingTime: 0,\n        dischargingTime: Infinity\n      },\n      device: {\n        hardwareConcurrency: navigator.hardwareConcurrency || 4,\n        deviceMemory: (navigator as any).deviceMemory || 4,\n        connection: 'unknown',\n        platform: navigator.platform,\n        isMobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)\n      }\n    };\n  }\n  \n  private setupPerformanceObservers(): void {\n    // Web Vitals observers\n    if ('PerformanceObserver' in window) {\n      // Largest Contentful Paint\n      try {\n        const lcpObserver = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          const lastEntry = entries[entries.length - 1] as any;\n          this.metrics.webVitals.lcp = lastEntry.startTime;\n          this.notifySubscribers();\n        });\n        lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\n        this.observers.set('lcp', lcpObserver);\n      } catch (error) {\n        console.warn('[Performance] LCP observer not supported:', error);\n      }\n      \n      // First Input Delay\n      try {\n        const fidObserver = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          entries.forEach((entry: any) => {\n            this.metrics.webVitals.fid = entry.processingStart - entry.startTime;\n          });\n          this.notifySubscribers();\n        });\n        fidObserver.observe({ entryTypes: ['first-input'] });\n        this.observers.set('fid', fidObserver);\n      } catch (error) {\n        console.warn('[Performance] FID observer not supported:', error);\n      }\n      \n      // Cumulative Layout Shift\n      try {\n        const clsObserver = new PerformanceObserver((list) => {\n          let clsValue = 0;\n          const entries = list.getEntries();\n          \n          entries.forEach((entry: any) => {\n            if (!entry.hadRecentInput) {\n              clsValue += entry.value;\n            }\n          });\n          \n          this.metrics.webVitals.cls = clsValue;\n          this.notifySubscribers();\n        });\n        clsObserver.observe({ entryTypes: ['layout-shift'] });\n        this.observers.set('cls', clsObserver);\n      } catch (error) {\n        console.warn('[Performance] CLS observer not supported:', error);\n      }\n      \n      // Navigation timing\n      try {\n        const navigationObserver = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          entries.forEach((entry: any) => {\n            this.metrics.webVitals.ttfb = entry.responseStart - entry.requestStart;\n          });\n          this.notifySubscribers();\n        });\n        navigationObserver.observe({ entryTypes: ['navigation'] });\n        this.observers.set('navigation', navigationObserver);\n      } catch (error) {\n        console.warn('[Performance] Navigation observer not supported:', error);\n      }\n      \n      // Long tasks observer\n      try {\n        const longTaskObserver = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          entries.forEach((entry: any) => {\n            if (entry.duration > 50) {\n              console.warn(`[Performance] Long task detected: ${entry.duration}ms`);\n              this.logPerformanceIssue('long-task', {\n                duration: entry.duration,\n                startTime: entry.startTime,\n                name: entry.name\n              });\n            }\n          });\n        });\n        longTaskObserver.observe({ entryTypes: ['longtask'] });\n        this.observers.set('longtask', longTaskObserver);\n      } catch (error) {\n        console.warn('[Performance] Long task observer not supported:', error);\n      }\n    }\n  }\n  \n  private detectDeviceCapabilities(): void {\n    // Network information\n    const connection = (navigator as any).connection || (navigator as any).mozConnection || (navigator as any).webkitConnection;\n    if (connection) {\n      this.metrics.network.connectionType = connection.type || 'unknown';\n      this.metrics.network.effectiveType = connection.effectiveType || 'unknown';\n      this.metrics.device.connection = connection.effectiveType || 'unknown';\n      \n      // Listen for network changes\n      connection.addEventListener('change', () => {\n        this.metrics.network.connectionType = connection.type || 'unknown';\n        this.metrics.network.effectiveType = connection.effectiveType || 'unknown';\n        this.notifySubscribers();\n      });\n    }\n    \n    // Battery API\n    if ('getBattery' in navigator) {\n      (navigator as any).getBattery().then((battery: any) => {\n        this.updateBatteryInfo(battery);\n        \n        battery.addEventListener('levelchange', () => this.updateBatteryInfo(battery));\n        battery.addEventListener('chargingchange', () => this.updateBatteryInfo(battery));\n        battery.addEventListener('chargingtimechange', () => this.updateBatteryInfo(battery));\n        battery.addEventListener('dischargingtimechange', () => this.updateBatteryInfo(battery));\n      }).catch((error: any) => {\n        console.warn('[Performance] Battery API not available:', error);\n      });\n    }\n  }\n  \n  private updateBatteryInfo(battery: any): void {\n    this.metrics.battery = {\n      level: battery.level,\n      charging: battery.charging,\n      chargingTime: battery.chargingTime,\n      dischargingTime: battery.dischargingTime\n    };\n    this.notifySubscribers();\n  }\n  \n  startMonitoring(): void {\n    if (this.isMonitoring) return;\n    \n    this.isMonitoring = true;\n    console.log('[Performance] Starting comprehensive monitoring');\n    \n    // Update metrics every second\n    this.updateInterval = setInterval(() => {\n      this.updateMetrics();\n    }, 1000);\n    \n    // Initial update\n    this.updateMetrics();\n  }\n  \n  stopMonitoring(): void {\n    if (!this.isMonitoring) return;\n    \n    this.isMonitoring = false;\n    console.log('[Performance] Stopping monitoring');\n    \n    if (this.updateInterval) {\n      clearInterval(this.updateInterval);\n      this.updateInterval = null;\n    }\n  }\n  \n  private updateMetrics(): void {\n    // Update memory metrics\n    if ((performance as any).memory) {\n      const memory = (performance as any).memory;\n      this.metrics.memory = {\n        usedJSHeapSize: memory.usedJSHeapSize,\n        totalJSHeapSize: memory.totalJSHeapSize,\n        jsHeapSizeLimit: memory.jsHeapSizeLimit,\n        trend: this.calculateMemoryTrend(memory.usedJSHeapSize)\n      };\n      \n      // Check memory warnings\n      if (memory.usedJSHeapSize > PERFORMANCE_THRESHOLDS.MEMORY_WARNING) {\n        this.logPerformanceIssue('memory-warning', {\n          usage: memory.usedJSHeapSize,\n          threshold: PERFORMANCE_THRESHOLDS.MEMORY_WARNING\n        });\n      }\n    }\n    \n    // Update network latency\n    this.measureNetworkLatency();\n    \n    // Calculate render time average\n    if (this.renderTimes.length > 0) {\n      this.metrics.renderTime.average = this.renderTimes.reduce((a, b) => a + b, 0) / this.renderTimes.length;\n      this.metrics.renderTime.max = Math.max(...this.renderTimes);\n    }\n    \n    // Store measurement history\n    this.measurementHistory.push({\n      timestamp: Date.now(),\n      metrics: {\n        memory: this.metrics.memory,\n        renderTime: this.metrics.renderTime,\n        network: this.metrics.network\n      }\n    });\n    \n    // Keep only last 100 measurements\n    if (this.measurementHistory.length > 100) {\n      this.measurementHistory = this.measurementHistory.slice(-100);\n    }\n    \n    this.notifySubscribers();\n  }\n  \n  private calculateMemoryTrend(currentUsage: number): 'stable' | 'increasing' | 'decreasing' {\n    this.memoryHistory.push(currentUsage);\n    \n    // Keep only last 10 measurements\n    if (this.memoryHistory.length > 10) {\n      this.memoryHistory = this.memoryHistory.slice(-10);\n    }\n    \n    if (this.memoryHistory.length < 5) return 'stable';\n    \n    const recent = this.memoryHistory.slice(-5);\n    const older = this.memoryHistory.slice(-10, -5);\n    \n    const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;\n    const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;\n    \n    const change = (recentAvg - olderAvg) / olderAvg;\n    \n    if (change > 0.05) return 'increasing';\n    if (change < -0.05) return 'decreasing';\n    return 'stable';\n  }\n  \n  private async measureNetworkLatency(): Promise<void> {\n    try {\n      const startTime = performance.now();\n      \n      // Use a small image or endpoint for latency measurement\n      const response = await fetch('/favicon.svg', {\n        method: 'HEAD',\n        cache: 'no-cache'\n      });\n      \n      if (response.ok) {\n        const endTime = performance.now();\n        this.metrics.network.latency = endTime - startTime;\n      }\n    } catch (error) {\n      // Network measurement failed, keep previous value\n    }\n  }\n  \n  // Render performance tracking\n  startRender(): () => void {\n    const startTime = performance.now();\n    \n    return () => {\n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n      \n      this.metrics.renderTime.current = renderTime;\n      this.renderTimes.push(renderTime);\n      \n      // Keep only last 60 render times (about 1 second at 60fps)\n      if (this.renderTimes.length > 60) {\n        this.renderTimes = this.renderTimes.slice(-60);\n      }\n      \n      // Check for slow renders\n      if (renderTime > PERFORMANCE_THRESHOLDS.RENDER_TIME_WARNING) {\n        this.metrics.renderTime.slowRenders++;\n        \n        if (renderTime > PERFORMANCE_THRESHOLDS.RENDER_TIME_CRITICAL) {\n          this.logPerformanceIssue('critical-render', {\n            renderTime,\n            threshold: PERFORMANCE_THRESHOLDS.RENDER_TIME_CRITICAL\n          });\n        }\n      }\n      \n      this.notifySubscribers();\n    };\n  }\n  \n  // Tactical-specific metrics\n  updateTacticalMetrics(data: {\n    playersRendered?: number;\n    formationComplexity?: number;\n    animationCount?: number;\n    interactionLatency?: number;\n  }): void {\n    Object.assign(this.metrics.tactical, data);\n    \n    // Check interaction latency\n    if (data.interactionLatency && data.interactionLatency > PERFORMANCE_THRESHOLDS.INTERACTION_WARNING) {\n      this.logPerformanceIssue('slow-interaction', {\n        latency: data.interactionLatency,\n        threshold: PERFORMANCE_THRESHOLDS.INTERACTION_WARNING\n      });\n    }\n    \n    this.notifySubscribers();\n  }\n  \n  // Formation complexity calculation\n  calculateFormationComplexity(formation: Formation, players: Player[]): number {\n    if (!formation || !players) return 0;\n    \n    let complexity = 0;\n    \n    // Base complexity from slot count\n    complexity += formation.slots.length * 10;\n    \n    // Add complexity for player assignments\n    const assignedSlots = formation.slots.filter(slot => slot.playerId);\n    complexity += assignedSlots.length * 5;\n    \n    // Add complexity for position variety\n    const roleTypes = new Set(formation.slots.map(slot => slot.role));\n    complexity += roleTypes.size * 15;\n    \n    // Add complexity for custom positions\n    const customPositions = formation.slots.filter(slot => \n      slot.defaultPosition.x !== Math.round(slot.defaultPosition.x) ||\n      slot.defaultPosition.y !== Math.round(slot.defaultPosition.y)\n    );\n    complexity += customPositions.length * 20;\n    \n    return Math.round(complexity);\n  }\n  \n  // Performance issue logging\n  private logPerformanceIssue(type: string, data: any): void {\n    const issue = {\n      type,\n      timestamp: Date.now(),\n      data,\n      userAgent: navigator.userAgent,\n      url: window.location.href,\n      metrics: this.metrics\n    };\n    \n    console.warn(`[Performance Issue] ${type}:`, issue);\n    \n    // In production, this could send to analytics service\n    if (typeof window !== 'undefined' && (window as any).gtag) {\n      (window as any).gtag('event', 'performance_issue', {\n        issue_type: type,\n        custom_parameter: JSON.stringify(data)\n      });\n    }\n  }\n  \n  // Subscription management\n  subscribe(callback: (metrics: PerformanceMetrics) => void): () => void {\n    this.subscribers.push(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      const index = this.subscribers.indexOf(callback);\n      if (index > -1) {\n        this.subscribers.splice(index, 1);\n      }\n    };\n  }\n  \n  private notifySubscribers(): void {\n    this.subscribers.forEach(callback => {\n      try {\n        callback(this.metrics);\n      } catch (error) {\n        console.error('[Performance] Subscriber callback error:', error);\n      }\n    });\n  }\n  \n  // Get current metrics\n  getMetrics(): PerformanceMetrics {\n    return { ...this.metrics };\n  }\n  \n  // Get performance summary\n  getPerformanceSummary(): {\n    overall: 'excellent' | 'good' | 'fair' | 'poor';\n    score: number;\n    issues: string[];\n    recommendations: string[];\n  } {\n    const issues: string[] = [];\n    const recommendations: string[] = [];\n    let score = 100;\n    \n    // Check Web Vitals\n    if (this.metrics.webVitals.lcp && this.metrics.webVitals.lcp > PERFORMANCE_THRESHOLDS.LCP_TARGET) {\n      issues.push('Slow Largest Contentful Paint');\n      recommendations.push('Optimize critical resource loading');\n      score -= 20;\n    }\n    \n    if (this.metrics.webVitals.fid && this.metrics.webVitals.fid > PERFORMANCE_THRESHOLDS.FID_TARGET) {\n      issues.push('High First Input Delay');\n      recommendations.push('Reduce JavaScript execution time');\n      score -= 15;\n    }\n    \n    if (this.metrics.webVitals.cls && this.metrics.webVitals.cls > PERFORMANCE_THRESHOLDS.CLS_TARGET) {\n      issues.push('High Cumulative Layout Shift');\n      recommendations.push('Reserve space for dynamic content');\n      score -= 15;\n    }\n    \n    // Check render performance\n    if (this.metrics.renderTime.average > PERFORMANCE_THRESHOLDS.RENDER_TIME_WARNING) {\n      issues.push('Slow rendering performance');\n      recommendations.push('Optimize component re-renders');\n      score -= 20;\n    }\n    \n    // Check memory usage\n    if (this.metrics.memory.trend === 'increasing') {\n      issues.push('Increasing memory usage');\n      recommendations.push('Check for memory leaks');\n      score -= 10;\n    }\n    \n    // Check tactical performance\n    if (this.metrics.tactical.interactionLatency > PERFORMANCE_THRESHOLDS.INTERACTION_WARNING) {\n      issues.push('Slow user interactions');\n      recommendations.push('Optimize event handlers and state updates');\n      score -= 15;\n    }\n    \n    // Check device limitations\n    if (this.metrics.device.isMobile && this.metrics.tactical.playersRendered > 50) {\n      recommendations.push('Consider virtualization for mobile devices');\n      score -= 5;\n    }\n    \n    // Check battery status\n    if (this.metrics.battery.level < 0.2 && !this.metrics.battery.charging) {\n      recommendations.push('Enable power-saving mode');\n    }\n    \n    // Determine overall rating\n    let overall: 'excellent' | 'good' | 'fair' | 'poor';\n    if (score >= 90) overall = 'excellent';\n    else if (score >= 75) overall = 'good';\n    else if (score >= 60) overall = 'fair';\n    else overall = 'poor';\n    \n    return {\n      overall,\n      score: Math.max(0, score),\n      issues,\n      recommendations\n    };\n  }\n  \n  // Get measurement history\n  getHistory(): Array<{ timestamp: number; metrics: Partial<PerformanceMetrics> }> {\n    return [...this.measurementHistory];\n  }\n  \n  // Reset metrics\n  reset(): void {\n    this.metrics = this.initializeMetrics();\n    this.measurementHistory = [];\n    this.memoryHistory = [];\n    this.renderTimes = [];\n    this.notifySubscribers();\n  }\n  \n  // Cleanup\n  destroy(): void {\n    this.stopMonitoring();\n    \n    // Disconnect all observers\n    this.observers.forEach(observer => {\n      observer.disconnect();\n    });\n    this.observers.clear();\n    \n    // Clear subscribers\n    this.subscribers = [];\n    \n    console.log('[Performance] Monitor destroyed');\n  }\n}\n\n// Global instance\nexport const performanceMonitor = CatalystPerformanceMonitor.getInstance();\n\n// React hooks for performance monitoring\nexport function usePerformanceMonitor() {\n  const [metrics, setMetrics] = React.useState<PerformanceMetrics | null>(null);\n  \n  React.useEffect(() => {\n    const monitor = performanceMonitor;\n    \n    // Start monitoring\n    monitor.startMonitoring();\n    \n    // Subscribe to updates\n    const unsubscribe = monitor.subscribe(setMetrics);\n    \n    // Initial metrics\n    setMetrics(monitor.getMetrics());\n    \n    return () => {\n      unsubscribe();\n      // Don't stop monitoring here as other components might be using it\n    };\n  }, []);\n  \n  return metrics;\n}\n\nexport function usePerformanceSummary() {\n  const [summary, setSummary] = React.useState(performanceMonitor.getPerformanceSummary());\n  \n  React.useEffect(() => {\n    const unsubscribe = performanceMonitor.subscribe(() => {\n      setSummary(performanceMonitor.getPerformanceSummary());\n    });\n    \n    return unsubscribe;\n  }, []);\n  \n  return summary;\n}\n\n// Utility functions\nexport function measureAsyncOperation<T>(operation: () => Promise<T>, name: string): Promise<T> {\n  return new Promise(async (resolve, reject) => {\n    const startTime = performance.now();\n    \n    try {\n      const result = await operation();\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      console.log(`[Performance] ${name}: ${duration.toFixed(2)}ms`);\n      \n      // Log slow operations\n      if (duration > 1000) {\n        performanceMonitor['logPerformanceIssue']('slow-operation', {\n          name,\n          duration\n        });\n      }\n      \n      resolve(result);\n    } catch (error) {\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      console.error(`[Performance] ${name} failed after ${duration.toFixed(2)}ms:`, error);\n      reject(error);\n    }\n  });\n}\n\nexport function measureSyncOperation<T>(operation: () => T, name: string): T {\n  const startTime = performance.now();\n  \n  try {\n    const result = operation();\n    const endTime = performance.now();\n    const duration = endTime - startTime;\n    \n    console.log(`[Performance] ${name}: ${duration.toFixed(2)}ms`);\n    \n    // Log slow operations\n    if (duration > 100) {\n      performanceMonitor['logPerformanceIssue']('slow-sync-operation', {\n        name,\n        duration\n      });\n    }\n    \n    return result;\n  } catch (error) {\n    const endTime = performance.now();\n    const duration = endTime - startTime;\n    \n    console.error(`[Performance] ${name} failed after ${duration.toFixed(2)}ms:`, error);\n    throw error;\n  }\n}\n\nexport default {\n  CatalystPerformanceMonitor,\n  performanceMonitor,\n  usePerformanceMonitor,\n  usePerformanceSummary,\n  measureAsyncOperation,\n  measureSyncOperation,\n  PERFORMANCE_THRESHOLDS\n};